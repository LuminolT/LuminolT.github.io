[{"authors":null,"categories":null,"content":"Luminol is a undergraduate of cyberspace security of Shanghai University. His research interests include cryptography and blochchain. He is the leader of Cake1salie, one CTF team of Shanghai University.\n","date":1670368837,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1670368837,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"Luminol is a undergraduate of cyberspace security of Shanghai University. His research interests include cryptography and blochchain. He is the leader of Cake1salie, one CTF team of Shanghai University.","tags":null,"title":"Luminol Chen","type":"authors"},{"authors":["Luminol Chen"],"categories":["Seed Lab"],"content":"This is a tip-page for TCP/IP Attack Lab of seed-lab project.\n1 - About gcc gcc is not installed on seed’s docker container. So when you need to compile the C program on heterogeneous platforms (like MacOSX, Arch etc.), you may encounter the glibc version-mismatch problem.\nTo cope with such situation, you can install the gcc yourself:\nAdd local sources on apt. nano /etc/apt/sources.list Recommended sources:\ndeb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse # deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse # deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse # deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse # deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multivers deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse # deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse Update the apt source and install gcc. apt update apt install gcc You are able to compile the C program on containers. 2 - About SYN Flood Attack (C Version) In this part, my computer crashed when lauching such attack to the victim with countermesuare (SYN Cookie) using C script. The reason is that the packet sending failure causes the dead loop to be too fast.\nYou can add a sleep statement to solve it:\n/********************************************************* Step 3: Finally, send the spoofed packet ********************************************************/ send_raw_ip_packet(ip); usleep(200); Note that usleep is for Linux/Unix Kernels’ POSIX.\n","date":1670368837,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1670368837,"objectID":"401cfb45b2ba4eac5b928a78c4096ebb","permalink":"https://example.com/post/seed-lab-tcp-ip/","publishdate":"2022-12-07T07:20:37+08:00","relpermalink":"/post/seed-lab-tcp-ip/","section":"post","summary":"计算机安全与保密技术 实验1 Tips","tags":["Seed Lab","Network Security"],"title":"Tips for TCP/IP Attack Lab","type":"post"},{"authors":["Luminol Chen"],"categories":["Operating System"],"content":" 请解释以下系统调用的详细含义。\nopen, close, read, write, lseek, link, mount\n1 - open open系统调用可以打开一个文件，其函数原型为：\nint open(const char *pathname, int flags, mode_t mode); 其中，pathname表示要打开文件的路径，flags表示访问模式，mode表示文件权限掩码，只能在文件创建时生效（i.e. flags==O_CREAT），返回值是一个文件描述符（file descriptor）。\n其中，flags必须包含访问模式，包括：\n只读模式：O_RDONLY 只写模式：O_WRONLY 读写模式：O_RDWR 除此之外的flags可以通过按位或的方式同时启用，包括：\nO_APPEND：增加模式：文件偏移量置于文件末尾； O_CREAT：创建模式：当pathname不存在，生成文件； O_TRUNC：截断模式：当文件可写，则抛弃原来内容。 例如，我们需要创建一个只写模式的文件1.txt，权限为rwxrwxrwx，可使用：\nint fd = open(\u0026#34;1.txt\u0026#34;, O_WRONLY | O_CREAT, 0777); 2 - close close系统调用可以关闭一个文件，其函数原型为：\nint close(int fd); 其中，fd表示要关闭的文件描述符（如open系统调用的返回值）。 返回值为0时，表示关闭成功，为-1时，表示系统错误， 且同时errno会被设置用于指示错误类型信息。\n3 - read read系统调用可以从一个文件描述符读数据，其函数原型为：\nssize_t read(int fd, void *buf, size_t count); 其中，fd表示要读取的文件描述符（同上），buf是指向读取存放空间的首地址， count是要读取字节数。成功读取时，返回读取的字节数*，反之返回-1，表示系统错误。\n*需注意，返回值可能会小于count值，该情况发生在读内容不足，遇到文件尾（End of File, EOF）时。\n4 - write write系统调用可以向一个文件描述符写数据，其函数原型为：\nssize_t write(int fd, const void *buf, size_t count); 其中，fd表示要写入的文件描述符（同上），buf是指向存放空间的首地址， count是要写入字节数。成功读取时，返回写入的字节数*，反之返回-1，表示系统错误。\n*同样，需注意返回值可能会小于count值，该情况发生在写空间不足时（空间有限，或设置了写入上限RLIMIT_FSIZE，或被信号中断）。\n5 - lseek lseek系统调用可以重定向读写文件的偏移量，其函数原型为：\noff_t lseek(int fd, off_t offset, int whence); 其中，fd表示要操作的文件描述符，offset表示偏移量，whence表示开始处标志（从何处开始）。当操作成功，返回结果偏移量，反之返回-1表示错误。\n其中whence可取值为：\nSEEK_SET：文件偏移量设置为offset字节； SEEK_CUR：文件偏移量设置为当前偏移量加上offset字节； SEEK_END：文件偏移量设置为文件大小加上offset字节*。 不难看出此处偏移量可以大于文件大小。当大于时，若继续调用write，则文件中会出现一段空隙，该空隙会被填充为\\0。\n6 - link link系统调用可以创建一个文件的硬链接，其函数原型为：\nint link(const char *oldpath, const char *newpath); 其中，oldpath表示被链接文件路径，newpath表示链接文件路径。 返回值为0则表示创建成功，为-1时表示创建失败。\n另需注意，当newpath非空时，不会覆盖原有链接，并且返回-1。\n7 - mount mount系统调用挂载一个文件系统，其函数原型为：\nint mount(const char *source, const char *target, const char *filesystemtype, unsigned long mountflags, const void *data); 其中：\nsource表示被挂载的文件系统（硬件设备、文件目录等等）； target表示挂载路径； filesystemtype表示被挂载的文件系统类型（btrfs, ext4, jfs等）； mountflags表示执行的操作； data由不同的文件系统解释，通常是一串以逗号分隔的选项。 其中，mountflags可取：\nMS_REMOUNT：对已有的挂载重挂载； MS_BIND：创建绑定挂载； MS_SHARED, MS_PRIVATE, MS_SLAVE, MS_UNBINDABLE：用于修改已有挂载的访问属性（propagation type）； MS_MOVE：将一个现有的挂载移动到另一处； 为空时，创建新挂载。 Reference: Linux Man Pages\n","date":1670260036,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1670260036,"objectID":"333221320eb4d622055d392fa3955cb3","permalink":"https://example.com/post/os-file-system/","publishdate":"2022-12-06T01:07:16+08:00","relpermalink":"/post/os-file-system/","section":"post","summary":"Linux文件系统相关系统调用","tags":["Operating System"],"title":"Linux System Calls - File System","type":"post"},{"authors":["Luminol Chen"],"categories":["Control Theory"],"content":" ⬆️ 这个乐队叫FUZZY CONTROL\n前置：你已经学习了智能控制的第三章，但是听不懂😫\n银行家问题 还记得反复出现的IF A THEN B、 IF A and B THEN C。你或许和笔者一样会思考，这东西到底有啥用！\n笔者找到了一个很有意思的解释，例如一个银行家想要给别人（张三）投资，那么他会考虑：\n如果张三的信用好，那么投资是低风险的 如果张三的信用一般，那么投资是中风险的 如果张三的信用不好，那么投资是高风险的 可以发现这就是银行家的知识。而模糊控制就是利用这种知识，进行系统控制的。\n这里我们加入一些术语，我们发现此处有两个语言变量：信用、投资风险，语言值分别为：\n信用：好、一般、不好 投资风险：高、中、低 接下来考虑模糊集的引入，如果使用一般逻辑，会导致信用级产生阶跃，显然在阶跃点的逻辑是很诡异的，因此引入了“模糊”的概念。\n因此，该系统的模型可以被罗列成这样：具体输入——模糊化——模糊推理——解模糊——具体输出\n模糊化 现在我们可以找一堆银行家对模糊的程度进行建模。比如说此处，对于信用度是好：\n100%的银行家觉得大于750的信用度是好的 50%的银行家觉得大于700的信用度是好的 …… 于是我们得到了一个简单的线性函数，当然实际情况可能更复杂，此处就不复杂化了~\n还记得吗？我们称这个函数为隶属函数，而“信用度是好”这件事对应了一个模糊集合$CG$（Credit Good），是由这个隶属函数所定义的。\n此处，我们的信用度准确值就是这个模糊集合的论域，为$[0,1000]$，利用隶属函数表示这个模糊集合为：\n$$ \\mu_{CG}(x) = \\begin{cases} 0, \u0026amp;0 \\leq x \u0026lt; 650\\\\ (x-650)/100, \u0026amp; 650 \\leq x \u0026lt;750\\\\ 1, \u0026amp;750 \\leq x \\leq 1000 \\end{cases} $$\n其余隶属函数不再罗列。\n考虑给定的实际输入为660，根据三个语言值对应模糊集得到的隶属度分别为$0,0.9,0.1$此时可合写为一个模糊向量 $[0,0.9,0.1]$。\n注意模糊向量并不是模糊集的向量表示法\n解模糊 假设我们的规则是直接对应，得到输出的模糊向量也为$[0,0.9,0.1]$，此时需要对其解模糊。对应首先我们要得到 投资风险这一语言变量所有语言值的隶属函数，如下图所示。\n解模糊有两种方法\n最大隶属度法：这个很简单，即发现模糊向量最大隶属度为$0.9$，对应语言值为中风险 重心法：有一个很诡异的公式，我们还是看图理解。 首先，我们考虑输入隶属度为$1$的情况。此时如果对应中风险，很容易想到解模糊的值是$0.5$， 因为它是中心对称的，取中点是比较合适的。那么如果是低风险这种梯形隶属函数呢？我们也想取一个中间的东西。\n先考虑二维离散情况，给定$x_1,x_2,\\cdots,x_n$我们可以得到其中心为$(\\sum x_i)/n$。进一步，如果我们把 隶属度看成一个权重乘入，为保证一致性，分母同样做变换，可以得到$(\\sum \\mu(x_i)x_i)/\\sum \\mu(x_i)$。\n然后我们考虑连续情况，直接进行一个积分号的变：\n$$ v_{out} = \\frac{\\int_\\Omega \\mu(x)x \\mathrm{d}x}{\\int_\\Omega \\mu(x_i)\\mathrm{d}x} $$\n太美丽了家人们，正好和重心公式对应（？\n然后我们考虑输入隶属度为$0.5$的情况。此时继续对应中风险，在风险程度为$0.375,0.625$时隶属度恰为$0.5$ 可以比较简单的求加权平均。但是我们考虑这两个点左右，也有对应的隶属度值在$0.5$附近，根据模糊的想法， 也应当考虑进来。此处就引入一个可用的方法，直接削顶，求底部的重心。最后通过一些神必求交就可以得到 该模糊向量对应的解模糊值。\n是不是感觉有些诡异，这种思路和Mamdani推理有相似之处，工程上能用就行~\nMamdani推理 给定 `IF x is A1 THEN y is B1, also IF x is A2 THEN y is B2\nMamdani推理是如何进行的？\n（未完待续）\n","date":1665484064,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1665484064,"objectID":"52e022e8fdb04dc00dde0dcbd5216f9e","permalink":"https://example.com/post/fuzzy-control/","publishdate":"2022-10-11T18:27:44+08:00","relpermalink":"/post/fuzzy-control/","section":"post","summary":"模糊控制系统从不会到不会","tags":["Control Theory","Fuzzy Logic"],"title":"Fuzzy Control","type":"post"},{"authors":["Luminol Chen","olivanpa","nofevid","crazylian"],"categories":["Operating System"],"content":"Lead in A：🤔为什么我写的程序跑的这么慢呢\nB：😂check the server，一核有难万核围观\n在多处理器系统越来越普及的时代，你需要学习——并发编程！\nPOSIX 为我们提供了线程库 (pthreads)，这是在多核平台上进行并发编程的一套API。\n本文，我们介绍三个内容：\n如何使用pthreads库创建并发线程 如何使用pthreads库实现线程同步（即OS同步原语的使用） 线程API的使用准则 Recall：在体系结构课中，我们使用了OpenMP，也是并发编程的一套接口， 其规范在编译器上实现，相较于pthreads更易于扩展。\n1 线程的创建和使用 1.1 主要函数接口 函数名 功能 int pthread_create() 创建线程 int pthread_detach() 分离线程 int pthread_equal() 比较线程 ID void pthread_exit() 终止线程 int pthread_join() 挂起并等待指定线程终止 int pthread_kill() 向线程发送信号 int pthread_once() 仅一次调用指定函数 pthread_t pthread_self() 返回线程 ID int pthread_cancel() 向线程发送取消信号 int pthread_setcancelstate() 设置本线程对取消信号的反应 int pthread_setcanceltype() 设置本线程取消动作的执行时机 void pthread_testcancel() 创建线程取消点 1.2 接口用法 1.2.1 创建线程 int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg) pthread_t *thread ：传递一个 pthread_t 类型的指针变量，也可以直接传递某个 pthread_t 类型变量的地址。\nconst pthread_attr_t *attr：用于手动设置新建线程的属性，例如线程的调用策略、线程所能使用的栈内存的大小等。大部分场景中，我们都不需要手动修改线程的属性，将 attr 参数赋值为 NULL，pthread_create() 函数会采用系统默认的属性值创建线程。\nvoid *(*start_routine) (void *)：以函数指针的方式指明新建线程需要调用的函数，该函数的参数最多有 1 个（可以省略不写），形参和返回值的类型都必须为 void* 类型。\nvoid *arg：指定传递给 start_routine 函数的实参，当不需要传递任何数据时，将 arg 赋值为 NULL 即可。\n1.2.2 分离线程 int pthread_detach(pthread_t thread) 表示线程运行结束后资源可被回收（线程所占用堆栈和线程描述符）。 1.2.3 比较线程 ID int pthread_equal(pthread_t t1, pthread_t t2) 比较线程 t1 和 t2 的线程 ID。如果相等，返回非零值；如果不相等，返回 0。 1.2.4 终止线程 void pthread_exit(void *value_ptr) void *value_ptr： 可以指向任何类型的数据，它指向的数据将作为线程退出时的返回值。如果线程不需要返回任何数据，将参数置为 NULL 即可。 1.2.5 挂起并等待指定线程终止 int pthread_join(pthread_t thread, void **value_ptr) pthread_t thread：等待终止的目标线程。 void **value_ptr：接收到的返回值，为 void pthread_exit(void *value_ptr) 中 void *value_ptr 指向的内容。 如果调用 int pthread_join() 函数的线程被取消，目标线程不会被分离。 1.2.6 向线程发送信号 int pthread_kill(pthread_t thread, int sig) sig：向指定线程 pthread_t thread 发送的信号。 1.2.7 仅一次调用指定函数 pthread_once_t once_control = PTHREAD_ONCE_INIT; int pthread_once(pthread_once_t *once_control, void (*init_routine)(void)) pthread_once_t *once_control：指定函数 init_routine 是否被调用的标志，需赋初值 PTHREAD_ONCE_INIT 以保证 int pthread_once() 函数正常调用。 void (*init_routine)(void)：指定函数 init_routine，在 once_control 值为 PTHREAD_ONCE_INIT 时，可被正常调用，随后使用再次调用 int pthread_once() 函数与相同 once_control，将不会再次调用 init_routine 函数。 1.2.8 返回线程 ID pthread_t pthread_self(void) 返回调用该函数的线程的线程 ID。 1.2.9 向线程发送取消信号 int pthread_cancel(pthread_t thread) 发送终止信号给 thread 线程，如果成功则返回 0，否则为非 0 值。发送成功并不意味着 thread 会终止。 1.2.10 设置本线程对取消信号的反应 int pthread_setcancelstate(int state, int *oldstate) int state ：具有两种取值 PTHREAD_CANCEL_ENABLE（缺省）和 PTHREAD_CANCEL_DISABLE， 分别表示收到信号后设为 CANCLED 状态和忽略 CANCEL 信号继续运行；old_state 如果不为 NULL 则存入原来的 Cancel 状态以便恢复。 1.2.11 设置本线程取消动作的执行时机 int pthread_setcanceltype(int type, int *oldtype) int type ：具有两种取值 PTHREAD_CANCEL_DEFFERED 和 PTHREAD_CANCEL_ASYCHRONOUS，仅当 Cancel 状态为 Enable 时有效，分别表示收到信号后继续运行至下一个取消点再退出和立即执行取消动作（退出）；oldtype 如果不为 NULL 则存入运来的取消动作类型值。 1.2.12 创建线程取消点 void pthread_testcancel(void) 在不包含取消点，但是又需要取消点的地方创建一个取消点，以便在一个没有包含取消点的执行代码线程中响应取消请求。 2 同步原语 2.1 互斥锁 2.1.1主要函数接口 函数名 功能 pthread_mutex_init() 初始化一个互斥锁 pthread_mutex_destroy() 销毁一个互斥锁 pthread_mutex_lock() 加锁 pthread_mutex_trylock() 尝试加锁 pthread_mutex_unlock() 解锁 2.1.2接口用法 2.1.2.1初始化一个互斥锁(互斥量) int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr); mutex：传出参数，调用时应传 \u0026amp;mutex\nattr：互斥量属性。是一个传入参数，通常传NULL，选用默认属性(线程间共享)。\n互斥锁初始化有两种方式：\n静态初始化：如果互斥锁 mutex 是静态分配的（定义在全局，或加了static关键字修饰），可以直接使用宏进行初始化。e.g. pthead_mutex_t\tmuetx = PTHREAD_MUTEX_INITIALIZER;\n动态初始化：局部变量应采用动态初始化。e.g. pthread_mutex_init(\u0026amp;mutex, NULL)\n2.1.2.2 加锁 int pthread_mutex_lock(pthread_mutex_t *mutex); 可视作mutex– 2.1.2.3 尝试加锁 int pthread_mutex_trylock(pthread_mutex_t *mutex); 2.1.2.4解锁 int pthread_mutex_unlock(pthread_mutex_t *mutex); 可视作mutex++ 2.1.2.5销毁互斥锁 int pthread_mutex_destroy(pthread_mutex_t *mutex); 2.2 条件变量 2.2.1主要函数接口 函数名 功能 pthread_cond_init() 初始化一个条件变量 pthread_cond_wait() 阻塞等待一个条件变量 pthread_cond_timedwait() 限时等待一个条件变量 pthread_cond_signal() 唤醒至少一个阻塞在条件变量上的线程 pthread_cond_broadcast() 唤醒全部阻塞在条件变量上的线程 pthread_cond_destroy() 销毁一个条件变量 2.2.2接口用法 2.2.2.1初始化一个条件变量 int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); cond：传出参数，传出参数，调用时应传 \u0026amp;mutex\nattr：attr表条件变量属性，通常为默认值，传NULL即可\n可以使用静态初始化的方法，初始化条件变量：\npthread_cond_t cond = PTHREAD_COND_INITIALIZER; 2.2.2.2阻塞等待一个条件变量 int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex); 函数作用： 阻塞等待条件变量cond（参1）满足\n释放已掌握的互斥锁（解锁互斥量）相当于pthread_mutex_unlock(\u0026amp;mutex);\n1,2两步为一个原子操作。\n当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁pthread_mutex_lock(\u0026amp;mutex);\n2.2.2.3限时等待一个条件变量 int pthread_cond_timedwait (pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime); abstime： 查看struct timespec结构体。\nstruct timespec { time_t tv_sec; /* seconds */ 秒 long tv_nsec; /* nanosecondes*/ 纳秒 } 形参abstime使用的是绝对时间。\n如：time(NULL)返回的就是绝对时间。而alarm(1)是相对时间，相对当前时间定时1秒钟。初始化struct timespec t = {1, 0};则pthread_cond_timedwait (\u0026amp;cond, \u0026amp;mutex, \u0026amp;t); 只能定时到 1970年1月1日 00:00:01秒 。\n正确用法：\n使用time_t …","date":1665481477,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1665481477,"objectID":"11a394827d6936cc73c794185d3a2706","permalink":"https://example.com/post/pthreads/","publishdate":"2022-10-11T17:44:37+08:00","relpermalink":"/post/pthreads/","section":"post","summary":"POSIX线程库小手册","tags":["Operating System"],"title":"A Brief Mannual to POSIX threads","type":"post"},{"authors":["Luminol Chen"],"categories":["Operating System"],"content":"信号量应用 3、用信号量描述同步：\n例： 某控制测量系统中，数据采集任务反复把 所采集的数据送入一个单缓冲区；计算任务不断从 该单缓冲区取出数据进行计算。\nvar buf; int flag = 0; collection() { while (ture) { // 采集数据； while(flag==1); // 将采集的数据放入buffer; flag=1; } } calculate() { while (ture) { while(flag==0); // 从buf中取出数据; flag=0; // 计算处理; } } 🤔 此处使用signal flag替代信号量，会不会产生问题？\nAnswer：可以看到此处while(flag==1);和while(flag==0);均为循环忙等的操作， 因此该方法和教材中整型信号量是一致的，因此会出现让权等待、有限等待不满足的问题。\n😉 问题解答结束，以下为相关的补充内容\n1 整型信号量 教材：整型信号量：\ntypedef int semaphore; P(semaphore sem) { while (sem\u0026lt;=0) ; /* 循环忙等 */ sem--; } V(semaphore sem) { sem++; } 存在循环忙等，和PPT给出方法是一致的，该方法显然不满足：\n让权等待：P操作循环忙等。 有限等待：某一线程V操作后其余线程竞争资源，其结果不确定。 2 整型信号量的小改进 此处我们消除循环忙等的过程，通过yield()让线程转让CPU使用权。\ntypedef int semaphore; P(semaphore sem) { bool succ = false; while (!succ) { if (sem \u0026gt; 0) { sem--; succ = true; } if (!succ) yield(); } } V(semaphore sem) { sem++; } 但是此时发现仅满足让权等待（yield()对应线程让权），但不满足有限等待（同1部分）。\n3 记录型信号量 教材：记录型信号量：利用PCB链式队列实现，仅需保证单条操作的原子性（through model-checker）\nmodel-checker 信号量的状态转移图\ntypedef struct { int value; struct PCB *list; } semaphore; P(semaphore *sem) { S-\u0026gt;value--; if (S-\u0026gt;value \u0026lt; 0) { block(S-\u0026gt;list); } } V(semaphore *sem) { S-\u0026gt;value++; if (S-\u0026gt;value \u0026lt;= 0) { wakeup(S-\u0026gt;list); } } 4 信号量（API实现） 进一步：信号量实际的实现，思想和教材中的记录型信号量相同，对应semaphore.h 的抽象。由于semaphore.h的源码不是很好找（笔者的系统上这个被链接了，需要一些 反汇编），此处给出OSTEP的实现：\nRef: https://github.com/remzi-arpacidusseau/ostep-code/blob/master/threads-sema/zemaphore.h\n#ifndef __zemaphore_h__ #define __zemaphore_h__ typedef struct __Zem_t { int value; pthread_cond_t cond; pthread_mutex_t lock; } Zem_t; void Zem_init(Zem_t *z, int value) { z-\u0026gt;value = value; Cond_init(\u0026amp;z-\u0026gt;cond); Mutex_init(\u0026amp;z-\u0026gt;lock); } void Zem_wait(Zem_t *z) { Mutex_lock(\u0026amp;z-\u0026gt;lock); while (z-\u0026gt;value \u0026lt;= 0) Cond_wait(\u0026amp;z-\u0026gt;cond, \u0026amp;z-\u0026gt;lock); z-\u0026gt;value--; Mutex_unlock(\u0026amp;z-\u0026gt;lock); } void Zem_post(Zem_t *z) { Mutex_lock(\u0026amp;z-\u0026gt;lock); z-\u0026gt;value++; Cond_signal(\u0026amp;z-\u0026gt;cond); Mutex_unlock(\u0026amp;z-\u0026gt;lock); } #ifdef __APPLE__ typedef Zem_t sem_t; #define Sem_wait(s) Zem_wait(s) #define Sem_post(s) Zem_post(s) #define Sem_init(s, v) Zem_init(s, v) #endif #endif // __zemaphore_h__ 可以看到使用了一个互斥锁和条件变量。\n事实上条件变量对应上面的的PCB队列，而block()和wakeup()的原子性， 对应这里条件变量的wait()和signal()通过互斥锁保证。\n","date":1665461172,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1665461172,"objectID":"f8634bcdf2d4bff01149b7153b7ab5cc","permalink":"https://example.com/post/about-semaphore/","publishdate":"2022-10-11T12:06:12+08:00","relpermalink":"/post/about-semaphore/","section":"post","summary":"Something about Semaphore","tags":["Operating System"],"title":"About Semaphore","type":"post"},{"authors":["Luminol Chen"],"categories":["Cryptography"],"content":"本文为基于同态性质的PPML方案的综述，以下为主要参考文献的信息：\nArticle: Efficient Dropout-resilient Aggregation for Privacy-preserving Machine Learning\nJournal: TIFS (IEEE Transactions on Information Forensics and Security)\nAuthor: Ziyao Liu, Jiale Guo, Kwok-Yan Lam, Jun Zhao\nDate: AUGUST 2021\n1. Background 机器学习是目前信息技术的一个主要方向，其要求数据量巨大的特性造成了对于用户共享数据集的需求。而为了保护用户的数据隐私，隐私保护机器学习（Privacy-preserving Machine Learning, PPML）近年来受到关注。\n在大规模机器学习中，用户或设备随时会退出（dropout），本文对此提出了一种可扩展的隐私聚合方案，通过同态伪随机数生成器（Homomorphic Pseudorandom Generator, HPRG）、Shamir秘密共享和数字签名方案，构建了一种PPML方案。该方案的特点包括：\n动态性：用户或设备可以随时退出； 安全性：可抵抗半诚实用户和恶意敌手的攻击； 高效性：相较于传统方案（SecAgg）更快。 Compare 以下为以往工作的一些特点：\nArticle Name Description Privacy-preserving stream aggregation with fault tolerance 阈值HE，高开销的building block，对大规模PPML不现实 Privacy-preserving deep learning via additively homomorphic encryption 比上述高效，但存在梯度泄露 Mpc-enabled privacypreserving neural network training against malicious attack 依靠MPC，DNN的通信开销很大 Aby3: A mixed protocol framework for machine learning 服务器辅助MPC，但对于单个服务器不能保证非共谋性 Falcon: Honest-majority maliciously secure framework for private deep learning 同上 Practical secure aggregation for privacy-preserving machine learning pair-wise DH，抗退出（弹性） 名词缩写\nHE：同态加密；MPC：多方安全计算；DNN：深度神经网络；DH：Diffie-Hellman\n2. Protocol 此处会提及两篇文章的内容，为方便下做简称：\nEDRAgg：即本文的主要参考文献，Efficient Dropout-resilient Aggregation for Privacy-preserving Machine Learning SecAgg：来自Google的最早的方案，Practical secure aggregation for privacy-preserving machine learning 2.1 Masking Model 首先需要明确我们的目标。在目前的研究中，PPML的底层是由安全聚合协议支持的。在该环境下，我们进行如下的定义：\n设存在用户集 $\\mathcal{U}$ 和服务器集 $\\mathcal{S}$，用户$u_i\\in \\mathcal{U}$拥有的ML模型参数记作$\\boldsymbol{x_i}$，则安全聚合的目标是在不泄露 $\\boldsymbol{x_i}$ 的任何信息的情况下，使得服务器获得聚合参数 $\\boldsymbol{y} = \\sum_{u_i \\in \\mathcal{U}} \\boldsymbol{x_i}$ 。\n🤔此处“不泄露”针对的是 $o_j \\in \\mathcal{U} \\cup \\mathcal{S} \\backslash \\{u_i\\}$\n类似完美安全性，$o_j$在协议前后的视角不变（同分布）\nAn Example 此处我们考虑两个用户，一个服务器的情况，即 $\\mathcal{U} = \\{u_1,u_2\\}$，$\\mathcal{S} = \\{s\\}$。\n此时，想要不泄露任何信息，可让用户对自己的模型参数加上遮罩（mask），再使服务器能够消除遮罩即可。我们将遮罩记作$\\boldsymbol{r_i}$，则有：\n$$ \\boldsymbol{y_i} = \\boldsymbol{x_i} + \\boldsymbol{r_i} $$\n于是对于两个用户的情况如下图所示，此处$r_i$为随机选取的随机数：\n此时，只需要服务器能过获得$\\sum \\boldsymbol{r} =\\boldsymbol{r_1} + \\boldsymbol{r_2}$，就可以消除遮罩，但显然这又变成了一个安全聚合问题。此时一个巧妙的方法是让$\\sum \\boldsymbol{r} =0$，即$\\boldsymbol{r_1} =- \\boldsymbol{r_2}$，对于该情况，可以让$u_1$向$u_2$发送$\\boldsymbol{r_1}$，如图：\n此时，$\\boldsymbol{y_1}+\\boldsymbol{y_2}$恰为$\\boldsymbol{x_1}+\\boldsymbol{x_2}$，且服务器从$\\boldsymbol{y_1},\\boldsymbol{y_2}$不能获得与$\\boldsymbol{x_1},\\boldsymbol{x_2}$相关的任何信息。\n需注意的是，此处要求$len(\\boldsymbol{r_i})\\geq len(\\boldsymbol{x_i})$，即满足One-time Pad，具有完美安全性。 但随之而来，会发现有一个问题，由于$u_2$从$u_1$处获得了$\\boldsymbol{r_1}$，如果$u_2$和服务器$s$共谋，则可以还原$\\boldsymbol{x_1}=\\boldsymbol{y_1}-\\boldsymbol{r_1}$，从而导致$u_1$的ML模型参数泄露。有什么方法可以让$u_1,u_2$双方共享一个数，并且不能被别人获取呢？此处就需要引入SecAgg的工作，巧妙利用Diffie-Hellman密钥交换算法来完成目标。\n此处我们省去关于DH密码学原语的详细说明，观察下图不难发现DH天然的给出了一个双方共享的数$g^{ab}$，且由于计算该数$g^{ab}=(g^a)^b=(g^b)^a$，要求一方的公钥和另一方的私钥，不会把信息泄露给第三方。\n这就得到了一个基于DH的安全聚合方法（作者称该过程为 pair-wise DH）。\n由于显然存在可逆映射$F:\\mathbb{Z}_p^k\\rightarrow \\mathbb{Z}_p$将参数向量降维，此处将$\\boldsymbol{r_i}$ 规约到 $\\mathbb{Z}_p$上，下同理。 Further Example, More Users 我们进一步扩展用户集的数量至3人，该方法是否还可行呢？\n我们可以从$u_1$的视角考虑：\n用户$u_1$除了自己的私钥$a$外，还可以得知$u_1,u_2,u_3$的公钥$g^a,g^b,g^c$，于是相关可计算$g^{ab},g^{ac}$。我们不妨使$u_1$的mask恰为$r_1=g^{ab}+g^{ac}$，那么与之对应在计算$u_2$的mask时，由于需要和$g^{ab}$配对相消，使之为$r_2=-g^{ab}+g^{bc}$，$u_3$同理，如图所示。\n不难归纳出该方法的计算公式： $$ y_i=x_i+\\sum_{i\u0026lt;j}g^{sk_isk_j}-\\sum_{i\u0026gt;j}g^{sk_isk_j} $$ 则显然： $$ y=\\sum_{u_i\\in\\mathcal{U}}{y_i}=\\sum_{u_i\\in\\mathcal{U}}{\\left(x_i+\\sum_{i\u0026lt;j}g^{sk_isk_j}-\\sum_{i\u0026gt;j}g^{sk_isk_j}\\right)}=\\sum_{u_i\\in\\mathcal{U}}{x} $$\nAnother Method （待更新……）\n2.2 Security Analysis （待更新……）\n3. Summary （待更新……）\n","date":1658046874,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1658046874,"objectID":"80d6ba894448dfb7e83faca4cc978cc6","permalink":"https://example.com/post/note-ppml/","publishdate":"2022-07-17T16:34:34+08:00","relpermalink":"/post/note-ppml/","section":"post","summary":"Efficient Dropout-resilient Aggregation for Privacy-preserving Machine Learning","tags":["Cryptography"],"title":"Note - HE-Based PPML","type":"post"},{"authors":["Luminol Chen"],"categories":[],"content":"什么是密码学？ 密码学是数学和计算机科学的交叉学科。在国内一般作为 信息安全专业的必修课程。密码学的开端是Shannon在1945年发表的《Communication Theory of Secrecy Systems》而在这之前，密码更像是一种技艺（Art）而非一种科学技术（Technique）。\nYou can check the Wiki Page for more information.\n按照Shannon理论，密码学可分为两个阶段：\n古典密码学：基于巧妙构造形成的Art 现代密码学：基于数学原理形成的Technique 古典密码学 一种比较有趣的，并且能在影视剧中看到的古典密码叫做滚筒密码。滚筒密码的加密原理就是双方规定好木棍的直径，写信人把腰带绑在木棍上书写，在收信人收到信之后，只需要把腰带绑到相同规格的木棍上就能还原信的内容。\n如果用现代密码学的语言去描述，信件的内容即为明文，通过滚筒写出来的纸片就是明文，而密钥就是那根木棍。\n而实质上我们可以发现，我们是在对一个字符串间隔取字符： 例如对串：Hello-Crypto!，我们把他写在正四棱柱形成的纸带上，就可以获得：Hoy!e-plCtlro，而这和隔4个字符1取的操作是一样的，我们可以给出一个形式化的代码实现：\n\u0026gt;\u0026gt;\u0026gt; def encrypt(msg: string, key: int) -\u0026gt; string: ... splitted_str = [\u0026#39;\u0026#39; for _ in range(key)] ... iter = 0 ... for ch in msg: ... splitted_str[iter].append(ch) ... iter += 1 ... cipher = \u0026#39;\u0026#39; ... cipher.join(splitted_str) \u0026gt;\u0026gt;\u0026gt; encrypt(\u0026#39;Hello-Crypto!\u0026#39;, 4) \u0026#39;Hoy!e-plCtlro\u0026#39; 而事实上，这就是一个栅栏密码，你可以在这个网站上尝试。\n解密过程偷懒不写啦，聪明如你一定能自己figure out!\n而这就是古典密码学从最原始的的阶段，步入了近现代的阶段。从一些工具的使用，变成了算数。在此基础上形成了大量的替换密码（如Caesar密码、Vigenère密码）。\n事实上computer最早的含义是计算员，大多都是一些熟练算术技巧的人来破译密码的，而我们熟知的Alan Turing事实上在二战时也是负责这个工作。\n现代密码学 现代密码学的开端是Shannon的那篇文章，其中提出了一个重要的概念，完美安全性（Perfect Security）。完美安全性的形式化定义用到了概率论的知识，因此此处不展开。我们仅对其产生的原因进行一些阐述。\n古典密码在当时基本全都被破解了，密码欠缺一个正式的、准确的定义去衡量证明一个密码方案是否具有严格的安全性，因此Shannon理论应运而生。\n一个密码体系保证完美安全性，当其加密后的密文不会透露任何关于明文的信息。而在这种定义下，即使攻击者拥有无穷的算力，也不能被破解。\n😮注意，是无穷的算力！\n但是根据Shannon的推论，一个保证完美安全性的密码体系，其密钥空间一定大于明文空间。也就是说，我的密钥不会比明文更短。而我们可以思考，如果有一个信道，可以安全的用于传输密钥，为什么不直接拿来传输明文呢？因此目前的密码体系都不保证完美安全性。\n而在这基础上，就催生了流密码和分块密码，他们被统称为对称密码学。总的来说，对称密码学致力于让短密钥经过一些神奇的操作，也可以发挥和长密钥相同的作用：\n流密码：通过随机数生成器序列，生成长密钥 分块密码：通过对明文分块，逐一用短密钥加密 此处是非常不严谨的表达，仅作为理解\n而与之对应的，是非对称密码学（又称为公钥密码学），该类密码体系的特点是拥有公钥和私钥两个密钥，他们往往基于数学上的难题进行规约：\nRSA：大数质因数分解难题 ElGamal：模乘群上的离散对数问题 ECC-ElGamal：椭圆曲线加法群上的离散对数问题 一个简单的例子是，给定两个大质数$p, q$，给你他们的乘积$N = pq$，你是很难分别求解出$p$和$q$的。\n😈试试吧！N = 115157048927615167000080222307830600550443405087336034834570254657109854848846966155326673813367130632850579378687042597345617010423842872052308839845927421052730005967200985762648016655477422221735535543563770813175765249421783025141172284969133662823566566070113584080582203941254237438639149018559749238997\n而这种数学上的难解特性就可以被利用，构造密码体系。\n具体需要一些数论和抽象代数的知识，这里就不展开啦~\n小结 事实上，上面两个问题都只解决了数据隐秘性的保护，不一定能够保证数据仍是完整的、未被篡改过的。而这就需要更多的知识，包括：\n消息认证码 数字签名 而目前随着量子计算机的出现，Shor算法已经从理论上证明了能够在多项式时间内攻破目前常见的密码体系，于是又有了一些后量子密码学的研究：\n格密码学 编码密码学 当然还有一些和其他方向的交叉，如：\n区块链（散列和共识机制） 安全多方计算（联邦学习） 零知识证明 学习路线 笔者的学习路线是：密码基础-数学基础-现代密码学，比较诡异，下面整理一下比较正常的路线：\n数学基础：离散数学、数论、近世代数、概率论 古典密码学：了解代换密码 对称密码学：流密码、对称密码、PRG、PRF 非对称密码学：Diffie-Hellman密钥交换、陷门函数、RSA、ElGamal、同态加密 应用密码学：哈希函数、消息认证码、数字签名 推荐一些书目：\nIntroduction to Modern Cryptography, Jonathan Katz and Yehuda Lindell 初等数论, 潘承洞、潘承彪 抽象代数学, 姚慕生 ","date":1655808773,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1655808773,"objectID":"257758fd8ac51219cb4cdd87a946f95f","permalink":"https://example.com/post/cryptography-guide/","publishdate":"2022-06-21T18:52:53+08:00","relpermalink":"/post/cryptography-guide/","section":"post","summary":"密码学学习路线","tags":["Cryptography"],"title":"A Guide for Newbies in Cryptography","type":"post"},{"authors":[],"categories":[],"content":"The following links are from my friends, you can check their personal page.\nChasing, Gopher, Major in Computer Science, SHU\nShaosy, ACMer, Major in Computer Engineering, NTU\n","date":1655397031,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1655397030,"objectID":"682d90e839cba34350570e9a59c9f241","permalink":"https://example.com/friend/","publishdate":"2022-06-17T00:30:31+08:00","relpermalink":"/friend/","section":"","summary":"The following links are from my friends, you can check their personal page.\nChasing, Gopher, Major in Computer Science, SHU\nShaosy, ACMer, Major in Computer Engineering, NTU","tags":[],"title":"Friend Link","type":"page"},{"authors":[],"categories":[],"content":"常用功能 | Common Function 官网 邮箱\t书籍查询\t网络课程\tPIM\t一网通办\t选课助手\t在线选课\n图书馆云打印\tACM-OJ\t洛谷\t视听说英语平台\t网安培养方案\n教务部\n","date":1655396647,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1655396647,"objectID":"e434ff7cfdee9f70a18276f9a509e1ae","permalink":"https://example.com/guide/","publishdate":"2022-06-17T00:24:07+08:00","relpermalink":"/guide/","section":"","summary":"常用功能 | Common Function 官网 邮箱\t书籍查询\t网络课程\tPIM\t一网通办\t选课助手\t在线选课\n图书馆云打印\tACM-OJ\t洛谷\t视听说英语平台\t网安培养方案\n教务部","tags":[],"title":"Guide","type":"page"},{"authors":["Luminol Chen"],"categories":["Tips"],"content":"前言 Hi 你好，如果你想选择网络空间安全作为你大学后 3 年的专业，但还在犹豫的话，可以看看这篇文章。\n笔者为上大 20 级直招网安本科生，现研究兴趣为密码学。本文主要为笔者对于大学两年网安学习的一些思考和总结，希望能作为 你选择专业的参考。\n网络空间安全是什么？ ~呜嗷呜~嗷嗷呜~呜嗷啊~嗷~嗷~嗷嗷~嗷呜呜呜呜呜嗷啊~呜嗷~呜呜~嗷啊啊~嗷啊呜呜啊~嗷啊嗷啊啊呜呜嗷~呜啊~啊呜~啊嗷呜啊嗷~啊呜啊~呜呜呜嗷~呜呜嗷呜呜嗷呜嗷呜啊嗷呜啊啊嗷呜呜嗷啊啊嗷啊~啊啊啊啊嗷呜呜啊嗷啊嗷啊~呜嗷呜~嗷~呜呜嗷呜呜嗷嗷嗷~啊嗷啊呜呜啊呜呜嗷呜嗷啊嗷啊嗷啊啊呜呜嗷嗷~呜啊啊嗷嗷~呜~嗷呜呜~啊嗷啊啊呜~嗷呜呜嗷嗷嗷呜~呜嗷嗷~呜啊啊嗷嗷~呜~嗷呜~呜~呜啊啊啊嗷嗷呜~嗷嗷~呜嗷呜嗷呜嗷嗷嗷啊呜啊嗷呜嗷呜啊~嗷呜~啊嗷嗷嗷嗷~呜嗷~啊啊啊呜呜嗷~呜呜嗷~嗷~呜嗷呜啊嗷啊嗷啊啊嗷嗷啊啊~呜啊嗷~嗷~嗷呜嗷啊~嗷嗷啊~啊嗷嗷~呜呜呜嗷~呜啊啊~嗷嗷呜呜~嗷啊嗷啊呜啊嗷嗷~呜啊呜呜~啊啊~嗷啊啊~嗷啊呜嗷嗷嗷~啊呜呜啊呜啊呜啊呜呜~呜啊~~~~嗷啊嗷嗷啊啊呜~~~~嗷啊啊啊呜嗷嗷~嗷~呜嗷啊呜嗷呜~啊嗷呜嗷嗷嗷呜嗷啊~呜呜嗷呜呜呜啊嗷呜~嗷呜~呜啊啊呜呜嗷~嗷啊~啊嗷呜嗷嗷啊嗷~啊~呜呜嗷呜嗷嗷~啊啊~啊嗷嗷啊~呜~呜嗷啊啊呜呜~嗷~嗷嗷呜嗷呜呜呜嗷呜~啊啊啊~嗷嗷啊~嗷嗷啊呜啊嗷啊啊~啊呜呜啊~呜呜嗷呜嗷嗷呜~啊嗷啊啊呜~嗷嗷嗷~嗷嗷呜呜~嗷啊啊~嗷啊呜啊呜~啊嗷~嗷嗷呜嗷呜嗷~嗷嗷~呜啊啊~嗷嗷呜呜~嗷啊~嗷呜~嗷嗷啊啊嗷嗷呜~啊啊呜呜嗷啊嗷~嗷嗷~啊呜呜呜呜嗷啊啊~呜嗷嗷嗷呜啊啊嗷呜嗷呜嗷呜呜啊啊~呜呜呜嗷嗷~啊呜啊呜嗷嗷~嗷~呜~嗷呜~啊啊啊~嗷啊呜呜嗷呜呜啊嗷嗷嗷啊啊啊~嗷呜啊嗷嗷~呜啊嗷嗷啊嗷~嗷呜呜啊嗷嗷呜啊呜呜~啊嗷嗷嗷呜啊呜呜嗷呜啊啊呜~~~~嗷啊呜~啊嗷呜嗷嗷嗷呜嗷啊~呜呜嗷呜呜呜啊嗷呜~呜~嗷啊嗷呜呜嗷嗷啊啊~嗷啊嗷嗷嗷~啊啊啊啊啊呜~呜~啊嗷~嗷呜~啊嗷呜~嗷呜呜嗷嗷嗷呜~呜呜嗷~嗷~嗷嗷~呜嗷~~~~嗷呜嗷啊嗷嗷呜啊呜嗷呜嗷嗷呜呜~啊嗷呜呜呜啊~嗷~嗷啊呜啊~呜呜嗷嗷嗷嗷呜呜嗷~嗷啊啊呜啊呜~呜呜嗷啊啊呜啊呜啊嗷呜呜~呜嗷嗷啊呜呜呜嗷~呜呜嗷啊~~~~嗷嗷嗷啊呜嗷呜呜呜啊嗷呜~呜啊嗷啊~嗷啊啊嗷呜嗷嗷~呜呜啊嗷呜嗷啊~啊呜~啊啊嗷~啊~呜呜嗷嗷嗷嗷呜嗷啊呜嗷啊啊呜呜啊嗷呜呜~啊~呜嗷嗷嗷呜啊啊嗷呜嗷嗷啊嗷啊呜嗷嗷呜啊呜啊呜~啊嗷呜~嗷啊~嗷呜嗷呜啊嗷呜嗷呜呜呜嗷嗷~呜啊啊嗷嗷~呜~嗷呜~嗷呜~啊啊呜呜嗷啊呜嗷呜嗷呜嗷呜呜~啊嗷嗷嗷呜~嗷嗷啊嗷~呜嗷~呜呜呜~呜~嗷嗷呜~嗷呜啊呜~呜啊呜~嗷啊嗷呜啊啊啊~啊呜呜呜啊~啊呜啊啊~呜呜嗷~呜~啊啊~呜~嗷嗷呜~呜嗷啊呜嗷嗷~啊嗷嗷~呜~呜嗷啊呜~呜嗷啊嗷啊嗷嗷嗷呜~啊啊呜嗷嗷~呜嗷呜啊嗷呜嗷嗷~嗷嗷~嗷啊呜嗷嗷嗷啊~呜啊啊呜呜嗷呜嗷嗷~呜嗷呜啊嗷呜嗷啊~嗷嗷啊嗷嗷啊啊呜呜啊啊呜嗷啊啊啊嗷嗷啊嗷啊嗷啊啊嗷呜呜嗷~呜啊呜呜啊啊嗷呜嗷啊啊啊啊呜嗷呜呜呜啊啊嗷啊呜嗷呜~嗷~啊嗷呜呜~呜~啊啊呜~呜~呜呜呜啊啊呜啊嗷啊呜啊啊呜呜~嗷~呜~啊啊呜呜嗷嗷嗷呜啊啊呜啊啊啊~啊嗷呜啊呜~啊嗷啊啊呜~呜嗷啊啊呜啊啊呜呜呜嗷嗷啊啊嗷~啊呜啊呜呜啊呜呜嗷嗷呜啊嗷呜啊~啊嗷~啊啊~呜嗷嗷嗷嗷呜啊呜啊嗷嗷~啊嗷嗷呜呜啊~嗷嗷嗷~嗷嗷呜呜~嗷啊啊~嗷啊啊啊~啊嗷呜啊~嗷呜~啊啊啊~嗷嗷啊~嗷嗷啊呜呜呜嗷嗷啊啊啊~啊呜~啊啊嗷~啊嗷啊嗷呜啊嗷呜嗷呜呜呜~啊啊呜嗷啊嗷呜嗷啊~啊啊呜呜啊呜呜啊啊嗷~啊啊~呜呜啊呜啊呜啊嗷嗷~呜啊呜嗷嗷嗷啊呜啊呜啊嗷嗷~啊嗷呜啊呜呜呜嗷呜~啊嗷啊呜~嗷啊呜呜~嗷嗷呜嗷呜嗷嗷嗷啊~嗷呜啊呜呜啊呜~呜嗷嗷啊~嗷嗷嗷嗷嗷啊嗷嗷啊呜嗷嗷~嗷~呜啊嗷~呜嗷嗷啊嗷~啊嗷嗷~啊嗷嗷呜~呜啊~啊啊嗷呜嗷啊嗷啊嗷嗷~啊嗷~嗷呜嗷啊呜呜啊嗷嗷~嗷啊呜呜嗷嗷啊呜~啊呜~嗷嗷啊啊呜呜啊呜啊~呜~嗷啊呜啊呜呜~啊嗷~嗷呜~啊啊呜呜嗷啊呜嗷呜嗷呜嗷啊嗷~嗷~呜呜呜呜嗷呜呜呜啊嗷呜啊嗷嗷嗷呜啊嗷呜啊啊嗷呜呜呜嗷嗷嗷嗷啊啊嗷嗷~呜嗷~嗷~呜啊~啊啊嗷呜嗷啊嗷嗷嗷呜呜嗷嗷~呜嗷呜呜啊呜啊啊啊嗷啊呜~嗷啊~嗷嗷啊~嗷嗷啊呜呜呜啊啊呜嗷啊啊啊啊啊啊嗷呜嗷嗷~呜~呜啊嗷啊嗷啊呜啊\n渗透测试：主要为 Web 方面，利用脚本进行攻防； 二进制安全：包括二进制漏洞挖掘和逆向工程； 密码学：有关数据数据传输、认证等。 ~呜嗷呜啊~嗷~啊嗷啊啊嗷嗷~呜啊呜嗷呜嗷呜呜嗷啊嗷啊啊呜啊嗷呜呜呜呜嗷~呜嗷啊嗷嗷~啊啊嗷啊嗷呜~啊啊呜嗷~嗷~呜啊嗷~呜呜嗷啊啊呜呜啊~嗷呜呜啊~啊啊啊呜~嗷嗷啊呜呜~呜~呜~嗷呜呜嗷嗷啊啊啊~啊呜呜嗷啊呜啊嗷呜~啊嗷啊啊呜~呜嗷~呜~啊啊~呜嗷嗷~呜~啊呜啊呜~啊嗷~啊嗷啊呜啊啊呜呜嗷呜嗷呜呜啊啊~呜嗷嗷嗷啊嗷嗷~啊呜~嗷啊嗷啊嗷嗷~嗷呜~嗷~呜啊啊~嗷嗷呜嗷呜嗷嗷嗷啊呜嗷嗷~嗷~呜~呜啊呜啊~嗷~嗷~呜啊嗷~呜呜~嗷啊嗷啊呜啊啊嗷~啊嗷~呜嗷嗷啊呜呜呜嗷~呜呜嗷啊啊嗷~嗷嗷呜嗷呜嗷~呜嗷呜啊啊~啊嗷呜啊~嗷啊嗷嗷呜嗷~呜呜呜啊啊啊~嗷~啊啊~啊~啊呜啊啊~嗷呜嗷啊嗷啊嗷嗷嗷呜嗷啊~啊啊啊啊~嗷啊呜嗷呜呜~呜啊嗷啊呜呜呜嗷啊~嗷啊啊~啊呜呜啊~呜啊~啊呜啊啊~嗷呜嗷啊嗷啊嗷嗷嗷呜嗷啊~啊啊啊啊~嗷啊呜嗷呜啊嗷嗷嗷~啊~啊~啊~嗷~嗷呜嗷啊呜嗷啊啊啊呜嗷啊呜嗷~嗷啊嗷呜~嗷~啊呜~呜啊啊呜嗷啊啊~嗷嗷啊啊嗷嗷呜~啊嗷啊啊呜嗷嗷呜呜嗷~呜啊呜呜啊啊嗷呜嗷啊啊啊啊呜嗷呜呜啊啊嗷呜~啊呜~啊嗷呜嗷嗷嗷呜嗷啊~呜呜嗷呜呜呜啊嗷呜~呜嗷嗷~嗷嗷~嗷嗷嗷~嗷嗷呜呜~嗷啊啊~嗷啊嗷嗷~呜~啊啊~嗷呜~啊~呜呜啊嗷~啊啊~呜嗷嗷嗷嗷呜啊啊~嗷呜啊嗷嗷嗷嗷呜嗷呜嗷~嗷嗷~啊嗷呜~呜啊呜啊啊嗷呜呜~呜啊嗷呜嗷嗷~呜嗷~呜呜嗷呜啊嗷呜嗷啊呜啊呜啊啊嗷呜嗷嗷啊呜~呜呜呜啊啊嗷~嗷啊嗷啊嗷~嗷嗷啊~呜呜嗷~啊呜呜~嗷啊啊~嗷啊呜呜啊~嗷啊啊~嗷啊啊~嗷啊呜嗷嗷嗷~啊嗷嗷嗷啊啊嗷嗷嗷嗷嗷啊嗷嗷啊呜嗷嗷啊呜嗷~啊啊嗷呜呜呜呜嗷啊啊呜啊呜呜啊呜嗷嗷嗷呜嗷啊呜啊呜啊嗷~啊啊~呜嗷嗷嗷呜啊啊呜啊啊啊~啊嗷呜啊~呜啊啊嗷啊嗷嗷嗷呜啊嗷啊呜啊嗷呜嗷嗷啊嗷嗷啊呜啊呜呜啊嗷~呜~啊嗷啊啊呜嗷嗷呜嗷呜呜啊啊~呜呜啊啊嗷啊嗷啊啊呜嗷嗷~嗷啊啊~呜呜嗷嗷嗷嗷呜嗷啊呜嗷啊呜~呜~啊啊呜~啊啊啊啊啊呜嗷啊嗷呜呜~呜嗷呜啊嗷呜呜啊嗷~嗷~嗷嗷嗷啊呜嗷嗷~嗷~呜~呜啊呜啊~嗷~嗷~呜呜~呜呜嗷啊啊呜呜啊啊呜呜啊~啊~嗷~呜呜嗷呜呜呜嗷啊\n网安学科竞赛？ 网安的学科竞赛一般分为两种，夺旗赛（Capture the Flag, CTF）和作品赛。\n作品赛主要是对于一些新兴技术的应用，使之成为有一定产业价值的工程。\n而夺旗赛主要是对于攻防技术的实际运用，一般会有这几个方向：\nMisc：杂项，包括数据隐写、流量分析，近两年也有人工智能、物联网相关应用； Pwn：二进制漏洞挖掘与应用，需要对程序原理和语言漏洞有一定了解； Reverse：逆向工程，包括各类语言，需要对汇编、算法有一定了解； Web：渗透测试漏洞挖掘，需要对网站框架、数据库、中间件、操作系统有一定了解； Crypto：密码学，需要对古典密码学、现代密码学有一定了解，近两年有加入区块链相关的内容。 可以看到和上述职业方向会有一定重合。而事实上，企业在招聘时也会考察你是否参加过 CTF 竞赛， 因此学网安的同学如果想要去比较好的公司，是一定要参加 CTF 竞赛的。\n网安考研？ 网安考研一般有两种情况：408 和高校自命题。\n408 主要考察数据结构、计算机组成原理、计算机网络、操作系统。\n高校自命题一般会删去数据结构和计组、增加密码学。\n有一种说法是，之前有部分高校转 408 后发现研究生不懂密码学，改回了自命题，因此需要各位对自己的意向校有所了解。\n网安人才缺口？ ~呜嗷呜呜嗷嗷啊啊啊~啊呜~啊啊嗷~啊啊~啊呜啊啊~嗷嗷呜~嗷呜啊呜~呜呜啊啊呜嗷啊啊呜~呜呜呜啊啊呜~嗷啊嗷~啊嗷呜嗷啊嗷~嗷嗷~啊呜嗷啊啊嗷~呜啊~啊~呜~嗷呜嗷~呜~嗷~嗷~呜嗷~啊呜嗷呜~呜啊啊呜~啊啊呜嗷啊~啊呜啊啊~呜~嗷~呜~啊啊呜嗷嗷嗷呜嗷啊~呜啊~呜嗷啊~啊嗷~呜呜嗷嗷啊呜嗷嗷啊嗷~嗷嗷~啊呜嗷嗷啊嗷~啊嗷嗷~啊嗷嗷呜嗷呜~啊啊嗷嗷~嗷啊呜啊啊~啊啊呜呜嗷嗷啊啊啊呜嗷嗷啊嗷嗷啊嗷啊呜嗷嗷呜嗷~呜嗷呜啊嗷呜嗷啊呜嗷~呜~啊呜嗷呜嗷啊嗷呜~呜嗷嗷呜~啊啊啊~嗷呜~嗷~啊呜呜啊啊~啊~啊啊啊啊嗷嗷嗷~嗷嗷嗷嗷啊啊嗷嗷呜嗷呜嗷呜嗷嗷嗷呜呜嗷嗷~呜嗷呜呜啊啊啊啊啊嗷啊呜嗷~呜嗷啊呜呜嗷嗷嗷呜呜嗷嗷~啊啊嗷嗷嗷~啊~嗷嗷呜啊呜啊啊嗷~啊啊~呜嗷嗷嗷呜啊啊呜啊啊啊~啊嗷呜啊~呜啊呜啊~嗷~嗷嗷啊呜呜呜啊嗷呜嗷啊~嗷呜嗷嗷啊嗷啊啊呜嗷呜啊啊啊啊嗷呜呜嗷嗷啊~啊啊啊啊嗷呜嗷嗷啊嗷~啊嗷嗷啊啊呜嗷嗷呜~啊呜嗷呜嗷啊呜呜啊嗷嗷啊~啊~呜嗷啊~啊嗷~呜呜嗷嗷啊呜嗷呜~啊嗷呜嗷嗷嗷呜嗷啊~呜呜嗷呜呜呜啊嗷呜~呜嗷啊~嗷嗷啊嗷呜啊嗷啊呜呜呜啊嗷嗷呜嗷呜嗷嗷啊嗷呜啊嗷啊~呜啊呜啊~嗷嗷嗷~嗷嗷呜呜~嗷啊啊~嗷啊~啊啊啊~嗷嗷~啊呜嗷呜呜呜嗷啊啊嗷啊嗷~啊呜嗷呜嗷呜嗷嗷啊啊啊~啊嗷呜啊~啊呜嗷呜呜嗷~嗷呜啊嗷啊啊呜啊啊~啊~啊啊啊~呜~啊嗷啊啊呜~嗷嗷~嗷嗷啊呜呜呜啊呜~呜嗷嗷啊~呜呜呜嗷嗷啊啊~啊嗷啊啊呜嗷呜呜啊嗷啊啊呜呜啊呜呜啊啊呜~嗷啊啊~啊~嗷呜~啊嗷嗷嗷嗷呜嗷呜~啊~呜呜~呜~啊啊呜~呜~呜呜呜啊啊呜~呜嗷啊嗷啊~呜嗷啊呜嗷呜~啊~呜呜呜嗷嗷嗷~呜啊啊啊~啊嗷呜啊呜嗷嗷啊啊~嗷呜嗷嗷嗷~呜嗷呜~呜~啊啊呜~啊呜嗷嗷~啊嗷嗷~啊嗷嗷啊啊啊嗷嗷呜啊啊~嗷呜嗷呜嗷嗷嗷呜嗷~呜嗷呜啊嗷~啊嗷啊呜啊啊呜呜嗷呜嗷嗷~嗷~啊啊嗷嗷呜嗷呜嗷嗷啊呜嗷呜~呜~嗷呜~啊啊啊嗷嗷嗷~嗷啊呜呜啊啊嗷嗷啊~嗷啊啊呜呜呜呜啊啊嗷嗷呜呜嗷嗷~嗷嗷嗷啊~嗷嗷~嗷啊呜嗷呜~嗷呜啊啊嗷嗷~啊啊嗷呜嗷~呜~嗷~嗷~嗷~呜啊嗷~呜呜~啊嗷嗷啊嗷~嗷嗷啊啊啊啊~呜~啊嗷啊啊嗷~嗷呜~嗷嗷~嗷啊呜~嗷啊呜呜啊呜啊嗷嗷啊~呜~呜呜嗷啊呜呜嗷嗷嗷啊~呜啊~呜呜呜嗷啊啊呜啊呜啊嗷嗷~嗷呜嗷嗷呜嗷呜嗷~嗷嗷~啊嗷呜~呜啊呜啊啊嗷呜呜~呜啊~嗷呜~呜嗷啊~~~~嗷啊呜嗷~呜嗷啊啊~呜嗷嗷呜啊嗷嗷~啊~呜啊~呜嗷啊~嗷嗷啊嗷呜呜啊啊呜呜啊呜~呜嗷嗷啊~嗷呜嗷嗷~嗷嗷~啊嗷呜~呜嗷啊啊嗷~啊啊~啊呜啊啊~啊呜嗷呜啊~嗷呜~呜呜呜呜嗷啊嗷啊~嗷呜啊呜嗷啊啊啊~呜嗷啊呜嗷呜呜~啊嗷啊啊呜~嗷~~~~啊呜呜呜呜嗷啊嗷呜~呜啊嗷嗷~嗷呜嗷呜~啊啊啊啊嗷嗷嗷嗷呜啊呜呜呜呜嗷嗷嗷呜啊嗷~呜嗷呜啊嗷嗷啊嗷~啊嗷呜嗷啊嗷~嗷嗷~啊呜嗷嗷嗷呜啊嗷呜啊呜嗷呜啊~嗷呜~呜呜呜呜嗷啊嗷啊~嗷呜呜嗷啊呜呜啊呜~嗷啊呜嗷呜~啊呜~呜嗷~呜嗷呜~啊~呜啊呜嗷嗷嗷啊~嗷呜~呜呜呜啊啊呜啊\n我决定要进网安了，有什么我可以做的吗？ 很高兴你能加入网安的大家庭，好好学习，上大网安的资源不会让你失望。\n在你正式开始大二学习之前，需要有几个准备：\n学会自主学习 这是计算机学科通用的一个准则了，在网安专业，大二期间仍然是在学习计算机科学的基础课程，但事实上这和你将来的就业基本无关。 因此你需要决定自己的方向，并且主动地自主地去查找资料学习。当然，也可以提问，前提是你看过《提问的智慧》。\nCTF 由于网安的人确实少，所以你可能会发现身边的人在参加 ACM、RoboMaster、超算、美赛这些比赛。但是请你搞清楚， 如果你将来还是走安全方向，这些与你将来的工作是没有关系的。笔者大一期间就加入了 ACM 集训队，后来认识到 其实是纯纯的浪费时间了，本身大一期间是可以尝试自己喜欢的东西，但是因为大类通识的存在，留给你的时间或许不多。\n~呜嗷嗷嗷嗷呜呜呜呜啊呜嗷呜呜啊嗷呜呜啊嗷啊呜~嗷啊~嗷呜啊呜呜呜啊呜啊啊呜嗷~啊呜嗷嗷呜呜嗷嗷~嗷呜~嗷啊啊呜嗷呜啊呜嗷呜嗷嗷呜嗷嗷呜啊啊嗷呜嗷嗷啊嗷~嗷呜~呜啊啊~嗷嗷啊~嗷啊呜~呜呜呜嗷嗷呜啊呜呜~嗷嗷嗷嗷啊嗷啊呜啊啊呜呜~嗷~呜~啊啊呜呜~呜~嗷呜啊~啊嗷呜嗷呜嗷啊嗷嗷呜啊呜啊~呜呜呜嗷~嗷啊啊呜啊呜呜嗷~嗷啊 …","date":1655337600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1655337600,"objectID":"e36ca221f7ce7041b69298204c421b30","permalink":"https://example.com/post/a-guide-for-newbies-in-cs/","publishdate":"2022-06-16T00:00:00Z","relpermalink":"/post/a-guide-for-newbies-in-cs/","section":"post","summary":"网络空间安全指北","tags":["网络空间安全","Tips"],"title":"A Guide for newbies in Cyberspace Security","type":"post"},{"authors":["Luminol Chen"],"categories":[],"content":"跨域资源共享 CORS 技术性定义 跨域资源共享（Cross-Origin Resource Sharing）是一个系统，它由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端JavaScript代码获取跨域请求的响应。\nCORS Header Access-Control-Allow-Origin 指示请求的资源能共享给哪些域。\nAccess-Control-Allow-Credentials 指示当请求的凭证标记为 true 时，是否响应该请求。\nAccess-Control-Allow-Headers 用在对预请求的响应中，指示实际的请求中可以使用哪些 HTTP 头。\nAccess-Control-Allow-Methods 指定对预请求的响应中，哪些 HTTP 方法允许访问请求的资源。\nAccess-Control-Expose-Headers 指示哪些 HTTP 头的名称能在响应中列出。\nAccess-Control-Max-Age 指示预请求的结果能被缓存多久。\nAccess-Control-Request-Headers 用于发起一个预请求，告知服务器正式请求会使用那些 HTTP 头。\nAccess-Control-Request-Method 用于发起一个预请求，告知服务器正式请求会使用哪一种 HTTP 请求方法。\nOrigin 指示获取资源的请求是从什么域发起的。\n了解更多，推荐阅读： https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS\n解决方法 响应头设置 让服务器设置一个响应头，允许浏览器向它发出跨域请求：\nAccess-Control-Allow-Origin: \u0026lt;Frontend_Server_IP\u0026gt; 当然更粗暴一点也可直接：\nAccess-Control-Allow-Origin: * 该方式表明 CORS 不考虑请求域，在开发时较为容易，但如果上线后会引起安全性问题（如构造POST请求）。\nGolang 代码实现 从网上找到了一个小小中间件：\nfunc CORSMiddleware() gin.HandlerFunc { return func(c *gin.Context) { c.Writer.Header().Set(\u0026#34;Access-Control-Allow-Origin\u0026#34;, \u0026#34;*\u0026#34;) c.Writer.Header().Set(\u0026#34;Access-Control-Allow-Credentials\u0026#34;, \u0026#34;true\u0026#34;) c.Writer.Header().Set(\u0026#34;Access-Control-Allow-Headers\u0026#34;, \u0026#34;Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With\u0026#34;) c.Writer.Header().Set(\u0026#34;Access-Control-Allow-Methods\u0026#34;, \u0026#34;POST, OPTIONS, GET, PUT\u0026#34;) if c.Request.Method == \u0026#34;OPTIONS\u0026#34; { c.AbortWithStatus(204) return } c.Next() } } // Ref : https://stackoverflow.com/questions/29418478/go-gin-framework-cors 加入路由引擎中：\nr := gin.Default() r.Use(CORSMiddleware()) 就OK辽 o(￣▽￣)ブ\n","date":1632017521,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1632017521,"objectID":"a253e93ba74f6ecc4428081063ff37ab","permalink":"https://example.com/post/a-simple-cors-issue/","publishdate":"2021-09-19T10:12:01+08:00","relpermalink":"/post/a-simple-cors-issue/","section":"post","summary":"后端开发手记，关于CORS接入封锁的解决","tags":["Web Service","Back-end","Golang"],"title":"A Simple CORS Issue","type":"post"},{"authors":["Luminol Chen"],"categories":["Golang"],"content":"前言 我烂了\nNil Golang的nil是对于传统C系语言null所做的一个安全性优化，笔者在学习map和slice有一些相关的疑惑。\n在如下代码运行后，map0和slice0的值均为nil：\nvar map0 map[string]int var slice0 []string 与之对应的是比较安全的建立方式，这种情况下建立的空map和空slice都非nil值：\nmap1 := make(map[string]int, 0) slice1 := make([]string, 0) 对map == nil 对于map增加键值对，前者会发生panic，而后者可以：\nmap0[\u0026#39;maths\u0026#39;] = 60\t//panic: assignment to entry in nil map map1[\u0026#39;maths\u0026#39;] = 60\t//OK 对slice == nil 对于slice的常规操作，则两者都可以进行：\nappend(slice0, \u0026#34;maths\u0026#34;) append(slice1, \u0026#34;maths\u0026#34;) range(slice0) range(slice1) len(slice0) len(slice1) 原因分析 map增加键值对的行为是在Golang底层实现的，而slice的append,range,len操作都是在builtin包内的函数实现的，对nil值情况做了差错控制。\n结论 用make，请。\n","date":1628355133,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1628355133,"objectID":"9a651881d233cbf47ced6ff8114d58ff","permalink":"https://example.com/post/nil-map-and-nil-slice/","publishdate":"2021-08-08T00:52:13+08:00","relpermalink":"/post/nil-map-and-nil-slice/","section":"post","summary":"关于nil map和nil slice","tags":["Golang"],"title":"Nil Map and Nil Slice in Golang","type":"post"},{"authors":["Luminol Chen"],"categories":["Mathsmatics"],"content":"0 前言 我烂了\n非数学专业书写，仅供微积分3考试参考，具体的拓展概念可能有错，欢迎交流讨论指正\n1 什么是常微分方程 (Ordinary Differential Equation)? ​\t在微积分课程中，我们学到的最后一个章节“微分方程”是被用来解决力学、天文学、物理学等，科学学科的实际问题的. 其中未知函数是一元函数的微分方程称作常微分方程 (Ordinary differential equation)，未知函数是多元函数的微分方程称作偏微分方程 (Partial differential equation).\n​\t其中，我们学习的部分为常微分方程（以下简称ODE），可以被1.1式定义： $$ F(x,\\frac{\\mathrm{d} y}{\\mathrm{d} x} ,\\frac{\\mathrm{d}^2 y}{\\mathrm{d} x^2} ,\\frac{\\mathrm{d}^3 y}{\\mathrm{d} x^3} ,\\cdots,\\frac{\\mathrm{d}^n y}{\\mathrm{d} x^n} )=0\\tag{1.1} $$ ​\t其中，$n$称为ODE的阶数 (Order)，是一个很重要的概念.\n1.1 什么是ODE的通解 (General Solution)? ​\tODE通解(General Solution)的维数应等同于方程阶数，也就是说对于一个二阶ODE，其通解应该有两个自由度 ($C_1$,$C_2$). 与其对应的是特解 (Particular Solution)\n​\t需要注意的是，通解不一定指所有解，例如对下微分方程： $$ e^x\\mathrm{d}y=y\\mathrm{d}x $$ ​\t该方程属于1.2节中最典型的可分离变量的ODE，经过变量分离，微分方程表示为以下形式 $$ \\frac{\\mathrm{d}x}{e^x}=\\frac{\\mathrm{d}y}{y} $$ ​\t两边积分得通解：$-e^{-x}=\\ln{\\left|y\\right|}+C$\n​\t值得注意的是，在计算过程中我们默认了$y≠0$，但当$y=0$时，可得特解$y^*=C$，但该特解并不包含在上述通解内，此时方程的所有解并不是我们求出的通解.\n​\t该特解被称为奇点的解，但我们在计算通解时不需要考虑.\n1.2 可分离变量的ODE (Separable variables ODE) ​\t形如1.2式的ODE称为可分离变量的ODE： $$ f(x)\\mathrm{d}y=g(y)\\mathrm{d}x\\tag{1.2} $$ ​\t可以通过变量分离，两遍积分求解： $$ \\int{\\frac{\\mathrm{d}x}{f(x)}}=\\int{\\frac{\\mathrm{d}y}{g(y)}}+C $$\n2 齐次方程 (Homogeneous ODE) 2.1 齐次性 ​\t齐次性描述的是一个函数符合以下性质，我们称这样的函数齐$k$次： $$ f(ax)=a^kf(x)\\tag{2.1} $$ ​\t例如：$f(x)=x^2+xy+y^2$，有$f(ax)=a^2(fx)$，为齐二次函数.\n2.2 齐次方程的形式 ​\t形如2.2式的ODE称为齐次ODE： $$ \\frac{\\mathrm{d} y}{\\mathrm{d} x}=g(\\frac{y}{x}) $$\n2.3 齐次方程的解法 ​\tStep1. 化为一阶可分离变量方程\n​\tStep2. 设$u=x/y$（比较坏的有$u=y/x$），则有： $$ \\frac{\\mathrm{d}y}{\\mathrm{d}x}=u+x\\frac{\\mathrm{d}u}{\\mathrm{d}x}\\tag{2.3} $$\n3 线性方程 (Linear ODE) 3.1 线性 ​\t线性描述的是一个函数符合以下性质： $$ f(ax)=af(x)\\tag{3.1} $$\n$$ f(x+y)=f(x)+f(y)\\tag{3.2} $$\n​\t具体见线性代数，有定义线性空间的8个基本性质\n​\tRmk: 线性操作是ODE中很关键的环节，微分算子$\\frac{\\mathrm{d}-}{\\mathrm{d}x}$、欧拉算子$D-$都是符合线性的\n3.2 一阶线性方程 3.2.1 一阶线性方程的形式 ​\t形如3.3式的ODE称为一阶线性ODE： $$ \\frac{\\mathrm{d}y}{\\mathrm{d}x}+P(x)y=Q(x)\\tag{3.3} $$ ​\t其中，若$Q(x)\\equiv 0$，则称该方程为齐次线性ODE，否则称之为非齐次线性ODE.\n3.2.2 一阶齐次线性方程的解法 ​\t属于可分离变量的ODE，可以直接记以下公式： $$ y=Ce^{-\\int{P(x)\\mathrm{d}x}}\\tag{3.4} $$\n3.2.3 一阶非齐次线性方程的解法 ​\t很关键的运用了常数变易法，即先猜测方程的解，带入验证，考试时还是直接记公式： $$ y=e^{-\\int{P(x)\\mathrm{d}x}}(\\int{Q(x)e^{\\int{P(x)\\mathrm{d}x}}\\mathrm{d}x+C})\\tag{3.5} $$\n3.3 伯努利方程 (Bernoulli ODE) 3.3.1伯努利方程的形式 ​\t形如3.6式的ODE称为伯努利方程： $$ \\frac{\\mathrm{d}y}{\\mathrm{d}x}+P(x)y=Q(x)y^n\\tag{3.6} $$\n3.3.2 伯努利方程的解法 ​\tStep1. 线性化 $$ y^{-n}\\frac{\\mathrm{d}y}{\\mathrm{d}x}+y^{1-n}P(x)=Q(x) $$ ​\tStep2. 凑微分 $$ \\frac{1}{1-n}\\frac{\\mathrm{d}y^{1-n}}{\\mathrm{d}x}+y^{1-n}P(x)=Q(x) $$ ​\tStep3. 换元整理 $$ \\frac{\\mathrm{d}z}{\\mathrm{d}x}+z(1-n)P(x)=(1-n)Q(x) $$ ​\tStep4. 当做一阶非齐次线性方程求解\n​\tStep5. 还元\n3.4 可降阶的高阶微分方程 ​\t害这不就是大学物理吗.\n3.5 高阶线性微分方程解的结构 ​\t害这不就是线性代数吗.\n3.6 常系数微分方程 3.6.1 常系数微分方程的形式 ​\t以二次常系数线性微分方程为例，其他也是一样的： $$ \\frac{\\mathrm{d}^2y}{\\mathrm{d}x^2}+p\\frac{\\mathrm{d}y}{\\mathrm{d}x}+qy=f(x)\\tag{3.7} $$ ​\t其中，若$f(x)\\equiv 0$，则称该方程为齐次的，反之为非齐次的.\n3.6.2 常系数齐次微分方程的解法 ​\tStep.1 写出对应方程的特征方程，以式3.7中方程为例，则为3.8式： $$ r^2+pr+q=0\\tag{3.8} $$ ​\tStep.2 根据解的情况，其通解形式也不同：\n特征方程根的情况 齐次微分方程的通解 $\\Delta\u0026gt;0$，不等实根 $r1,r2$ $y=C_1e^{r_1x}+C_2e^{r_2x}$ $\\Delta=0$，二重实根 $r$ $y=(C_1+C_2x)e^{rx}$ $\\Delta\u0026lt;0$，共轭虚根 $\\lambda \\pm \\omega i$ $y=e^{\\lambda x}(C_1\\cos{\\omega x}+C_2\\sin{\\omega x})$ 3.6.3 常系数非齐次微分方程的解法 ​\t首先，解出对应齐次方程的通解$y_g$，再用常数变易法求特解\n​\t其中，我们能够解决的只对应两种情况，即为3.7式中$f(x)=P_n(x)e^{\\alpha x}$ 或 $f(x)=P_n(x)e^{(\\lambda+\\omega i) x}$，\n​\t公式理解比较麻烦，建议直接看例题.\n3.7 欧拉方程(Euler Equation) ​\t以二阶为例，形如3.9式的方程称为欧拉方程： $$ x^2\\frac{\\mathrm{d}^2y}{\\mathrm{d}x^2}+xp\\frac{\\mathrm{d}y}{\\mathrm{d}x}+qy=f(x)\\tag{3.8} $$ ​\t设$x=e^t$，并引入欧拉算子$\\mathrm{D}=\\frac{\\mathrm{d}}{\\mathrm{d}t}=x\\frac{\\mathrm{d}}{\\mathrm{d}x}$\n​\t则原方程可化为： $$ \\mathrm{D}^2y+p\\mathrm{D}y+qy=g(t) $$ ​\t然后按照3.6.3继续求解即可\n4 全微分方程(Totol Differential Equation) 4.1 全微分方程的条件 ​\t对方程$P(x,y)\\mathrm{d}x+Q(x,y)\\mathrm{d}y=0$，若满足$\\frac{\\partial Q}{\\partial x} =\\frac{\\partial P}{\\partial y}$，则称该方程为全微分方程.\n4.2 全微分方程的解法 4.2.1 公式法 ​\t公式如4.1式，注意$(x_0,y_0)$的选取，一定在函数的定义域内： $$ u(x,y)=\\int_{x_0}^{x}{P(x,y)\\mathrm{d}x}+\\int_{y_0}^{y}{Q(x_0,y)\\mathrm{d}y}\\tag{4.1} $$\n4.2.2 偏积分法 ​\t和常数变易法类似，用不太到，算咯.\n4.2.3 烧香拜佛法 ​\t随缘凑微分，没什么好讲的.\n4.3 积分因子 ​\t取一个神秘的$\\mu(x,y)$使得$\\mu(x,y)P(x,y)\\mathrm{d}x+\\mu(x,y)Q(x,y)\\mathrm{d}y=0$变成全微分方程.\n​\t随缘凑微分，没什么好讲的.\n","date":1622825944,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1622825944,"objectID":"00cd9cb37c0898f373891d7b42795a24","permalink":"https://example.com/post/calculus-3-ode/","publishdate":"2021-06-05T00:59:04+08:00","relpermalink":"/post/calculus-3-ode/","section":"post","summary":"微积分(3)常微分方程部分整理","tags":["Calculus"],"title":"Calculus(3) ODE Part","type":"post"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Wowchemy Wowchemy | Documentation\nFeatures Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides Controls Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026#34;blueberry\u0026#34; if porridge == \u0026#34;blueberry\u0026#34;: print(\u0026#34;Eating...\u0026#34;) Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\nFragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}} Press Space to play!\nOne Two Three A fragment can accept two optional parameters:\nclass: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}} Press the S key to view the speaker notes!\nOnly the speaker can read these notes Press S key to view Themes black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026#34;/media/boards.jpg\u0026#34; \u0026gt;}} {{\u0026lt; slide background-color=\u0026#34;#0000FF\u0026#34; \u0026gt;}} {{\u0026lt; slide class=\u0026#34;my-style\u0026#34; \u0026gt;}} Custom CSS Example Let’s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; } Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"https://example.com/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Wowchemy's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":null,"categories":null,"content":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\n","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"e8f8d235e8e7f2efd912bfe865363fc3","permalink":"https://example.com/project/example/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/example/","section":"project","summary":"An example of using the in-built project page.","tags":["Deep Learning"],"title":"Example Project","type":"project"},{"authors":["Luminol Chen","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software. Create your slides in Markdown - click the Slides button to check out the example. Supplementary notes can be added here, including code, math, and images.\n","date":1372636800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1372636800,"objectID":"ff6a19061a984819d30c916886db56ef","permalink":"https://example.com/publication/example/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/example/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":[],"title":"An example conference paper","type":"publication"}]