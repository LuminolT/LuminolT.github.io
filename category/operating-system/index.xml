<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Operating System | Luminolt</title><link>https://example.com/category/operating-system/</link><atom:link href="https://example.com/category/operating-system/index.xml" rel="self" type="application/rss+xml"/><description>Operating System</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Tue, 06 Dec 2022 01:07:16 +0800</lastBuildDate><image><url>https://example.com/media/icon_hu1b90dea3b5752ec4ed6154c0dc881a21_30314_512x512_fill_lanczos_center_3.png</url><title>Operating System</title><link>https://example.com/category/operating-system/</link></image><item><title>Linux System Calls - File System</title><link>https://example.com/post/os-file-system/</link><pubDate>Tue, 06 Dec 2022 01:07:16 +0800</pubDate><guid>https://example.com/post/os-file-system/</guid><description>&lt;blockquote>
&lt;p>请解释以下系统调用的详细含义。&lt;/p>
&lt;p>&lt;code>open&lt;/code>, &lt;code>close&lt;/code>, &lt;code>read&lt;/code>, &lt;code>write&lt;/code>, &lt;code>lseek&lt;/code>, &lt;code>link&lt;/code>, &lt;code>mount&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;h2 id="1---open">1 - &lt;code>open&lt;/code>&lt;/h2>
&lt;p>&lt;code>open&lt;/code>系统调用可以打开一个文件，其函数原型为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">pathname&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">flags&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">mode_t&lt;/span> &lt;span class="n">mode&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中，&lt;code>pathname&lt;/code>表示要打开文件的路径，&lt;code>flags&lt;/code>表示访问模式，&lt;code>mode&lt;/code>表示文件权限掩码，只能在文件创建时生效（i.e. &lt;code>flags==O_CREAT&lt;/code>），返回值是一个文件描述符（file descriptor）。&lt;/p>
&lt;p>其中，&lt;code>flags&lt;/code>必须包含访问模式，包括：&lt;/p>
&lt;ul>
&lt;li>只读模式：&lt;code>O_RDONLY&lt;/code>&lt;/li>
&lt;li>只写模式：&lt;code>O_WRONLY&lt;/code>&lt;/li>
&lt;li>读写模式：&lt;code>O_RDWR&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>除此之外的&lt;code>flags&lt;/code>可以通过按位或的方式同时启用，包括：&lt;/p>
&lt;ul>
&lt;li>&lt;code>O_APPEND&lt;/code>：增加模式：文件偏移量置于文件末尾；&lt;/li>
&lt;li>&lt;code>O_CREAT&lt;/code>：创建模式：当&lt;code>pathname&lt;/code>不存在，生成文件；&lt;/li>
&lt;li>&lt;code>O_TRUNC&lt;/code>：截断模式：当文件可写，则抛弃原来内容。&lt;/li>
&lt;/ul>
&lt;p>例如，我们需要创建一个只写模式的文件&lt;code>1.txt&lt;/code>，权限为&lt;code>rwxrwxrwx&lt;/code>，可使用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;1.txt&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">O_WRONLY&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">O_CREAT&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mo">0777&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="2---close">2 - &lt;code>close&lt;/code>&lt;/h2>
&lt;p>&lt;code>close&lt;/code>系统调用可以关闭一个文件，其函数原型为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中，&lt;code>fd&lt;/code>表示要关闭的文件描述符（如&lt;code>open&lt;/code>系统调用的返回值）。
返回值为&lt;code>0&lt;/code>时，表示关闭成功，为&lt;code>-1&lt;/code>时，表示系统错误，
且同时&lt;code>errno&lt;/code>会被设置用于指示错误类型信息。&lt;/p>
&lt;h2 id="3---read">3 - &lt;code>read&lt;/code>&lt;/h2>
&lt;p>&lt;code>read&lt;/code>系统调用可以从一个文件描述符读数据，其函数原型为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">ssize_t&lt;/span> &lt;span class="nf">read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">size_t&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中，&lt;code>fd&lt;/code>表示要读取的文件描述符（同上），&lt;code>buf&lt;/code>是指向读取存放空间的首地址，
&lt;code>count&lt;/code>是要读取字节数。成功读取时，返回读取的字节数*，反之返回&lt;code>-1&lt;/code>，表示系统错误。&lt;/p>
&lt;p>*需注意，返回值可能会小于&lt;code>count&lt;/code>值，该情况发生在读内容不足，遇到文件尾（End of File, EOF）时。&lt;/p>
&lt;h2 id="4---write">4 - &lt;code>write&lt;/code>&lt;/h2>
&lt;p>&lt;code>write&lt;/code>系统调用可以向一个文件描述符写数据，其函数原型为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">ssize_t&lt;/span> &lt;span class="nf">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">size_t&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中，&lt;code>fd&lt;/code>表示要写入的文件描述符（同上），&lt;code>buf&lt;/code>是指向存放空间的首地址，
&lt;code>count&lt;/code>是要写入字节数。成功读取时，返回写入的字节数*，反之返回&lt;code>-1&lt;/code>，表示系统错误。&lt;/p>
&lt;p>*同样，需注意返回值可能会小于&lt;code>count&lt;/code>值，该情况发生在写空间不足时（空间有限，或设置了写入上限&lt;code>RLIMIT_FSIZE&lt;/code>，或被信号中断）。&lt;/p>
&lt;h2 id="5---lseek">5 - &lt;code>lseek&lt;/code>&lt;/h2>
&lt;p>&lt;code>lseek&lt;/code>系统调用可以重定向读写文件的偏移量，其函数原型为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">off_t&lt;/span> &lt;span class="nf">lseek&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">off_t&lt;/span> &lt;span class="n">offset&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">whence&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中，&lt;code>fd&lt;/code>表示要操作的文件描述符，&lt;code>offset&lt;/code>表示偏移量，&lt;code>whence&lt;/code>表示开始处标志（从何处开始）。当操作成功，返回结果偏移量，反之返回&lt;code>-1&lt;/code>表示错误。&lt;/p>
&lt;p>其中&lt;code>whence&lt;/code>可取值为：&lt;/p>
&lt;ul>
&lt;li>&lt;code>SEEK_SET&lt;/code>：文件偏移量设置为&lt;code>offset&lt;/code>字节；&lt;/li>
&lt;li>&lt;code>SEEK_CUR&lt;/code>：文件偏移量设置为当前偏移量加上&lt;code>offset&lt;/code>字节；&lt;/li>
&lt;li>&lt;code>SEEK_END&lt;/code>：文件偏移量设置为文件大小加上&lt;code>offset&lt;/code>字节*。&lt;/li>
&lt;/ul>
&lt;p>不难看出此处偏移量可以大于文件大小。当大于时，若继续调用&lt;code>write&lt;/code>，则文件中会出现一段空隙，该空隙会被填充为&lt;code>\0&lt;/code>。&lt;/p>
&lt;h2 id="6---link">6 - &lt;code>link&lt;/code>&lt;/h2>
&lt;p>&lt;code>link&lt;/code>系统调用可以创建一个文件的硬链接，其函数原型为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">link&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">oldpath&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">newpath&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中，&lt;code>oldpath&lt;/code>表示被链接文件路径，&lt;code>newpath&lt;/code>表示链接文件路径。
返回值为&lt;code>0&lt;/code>则表示创建成功，为&lt;code>-1&lt;/code>时表示创建失败。&lt;/p>
&lt;p>另需注意，当&lt;code>newpath&lt;/code>非空时，不会覆盖原有链接，并且返回&lt;code>-1&lt;/code>。&lt;/p>
&lt;h2 id="7---mount">7 - &lt;code>mount&lt;/code>&lt;/h2>
&lt;p>&lt;code>mount&lt;/code>系统调用挂载一个文件系统，其函数原型为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">mount&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">source&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">target&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">filesystemtype&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">mountflags&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>&lt;code>source&lt;/code>表示被挂载的文件系统（硬件设备、文件目录等等）；&lt;/li>
&lt;li>&lt;code>target&lt;/code>表示挂载路径；&lt;/li>
&lt;li>&lt;code>filesystemtype&lt;/code>表示被挂载的文件系统类型（btrfs, ext4, jfs等）；&lt;/li>
&lt;li>&lt;code>mountflags&lt;/code>表示执行的操作；&lt;/li>
&lt;li>&lt;code>data&lt;/code>由不同的文件系统解释，通常是一串以逗号分隔的选项。&lt;/li>
&lt;/ul>
&lt;p>其中，&lt;code>mountflags&lt;/code>可取：&lt;/p>
&lt;ul>
&lt;li>&lt;code>MS_REMOUNT&lt;/code>：对已有的挂载重挂载；&lt;/li>
&lt;li>&lt;code>MS_BIND&lt;/code>：创建绑定挂载；&lt;/li>
&lt;li>&lt;code>MS_SHARED, MS_PRIVATE, MS_SLAVE, MS_UNBINDABLE&lt;/code>：用于修改已有挂载的访问属性（propagation type）；&lt;/li>
&lt;li>&lt;code>MS_MOVE&lt;/code>：将一个现有的挂载移动到另一处；&lt;/li>
&lt;li>为空时，创建新挂载。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Reference: &lt;a href="https://man7.org/linux/man-pages/" target="_blank" rel="noopener">Linux Man Pages&lt;/a>&lt;/p>
&lt;/blockquote></description></item><item><title>A Brief Mannual to POSIX threads</title><link>https://example.com/post/pthreads/</link><pubDate>Tue, 11 Oct 2022 17:44:37 +0800</pubDate><guid>https://example.com/post/pthreads/</guid><description>&lt;h2 id="lead-in">Lead in&lt;/h2>
&lt;blockquote>
&lt;p>A：🤔为什么我写的程序跑的这么慢呢&lt;/p>
&lt;p>B：😂check the server，一核有难万核围观&lt;/p>
&lt;/blockquote>
&lt;img src="https://picgo-1303220879.cos.ap-shanghai.myqcloud.com/img/20221011090209.png" width="300" align="center"/>
&lt;p>在多处理器系统越来越普及的时代，你需要学习——并发编程！&lt;/p>
&lt;p>POSIX 为我们提供了线程库 (pthreads)，这是在多核平台上进行并发编程的一套API。&lt;/p>
&lt;p>本文，我们介绍三个内容：&lt;/p>
&lt;ul>
&lt;li>如何使用pthreads库创建并发线程&lt;/li>
&lt;li>如何使用pthreads库实现线程同步（即OS同步原语的使用）&lt;/li>
&lt;li>线程API的使用准则&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Recall：在体系结构课中，我们使用了&lt;a href="https://en.wikipedia.org/wiki/OpenMP" target="_blank" rel="noopener">OpenMP&lt;/a>，也是并发编程的一套接口，
其规范在编译器上实现，相较于pthreads更易于扩展。&lt;/p>
&lt;/blockquote>
&lt;h2 id="1-线程的创建和使用">1 线程的创建和使用&lt;/h2>
&lt;h3 id="11-主要函数接口">1.1 主要函数接口&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>函数名&lt;/th>
&lt;th>功能&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>int pthread_create()&lt;/code>&lt;/td>
&lt;td>创建线程&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>int pthread_detach()&lt;/code>&lt;/td>
&lt;td>分离线程&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>int pthread_equal()&lt;/code>&lt;/td>
&lt;td>比较线程 ID&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>void pthread_exit()&lt;/code>&lt;/td>
&lt;td>终止线程&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>int pthread_join()&lt;/code>&lt;/td>
&lt;td>挂起并等待指定线程终止&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>int pthread_kill()&lt;/code>&lt;/td>
&lt;td>向线程发送信号&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>int pthread_once()&lt;/code>&lt;/td>
&lt;td>仅一次调用指定函数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>pthread_t pthread_self()&lt;/code>&lt;/td>
&lt;td>返回线程 ID&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>int pthread_cancel()&lt;/code>&lt;/td>
&lt;td>向线程发送取消信号&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>int pthread_setcancelstate()&lt;/code>&lt;/td>
&lt;td>设置本线程对取消信号的反应&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>int pthread_setcanceltype()&lt;/code>&lt;/td>
&lt;td>设置本线程取消动作的执行时机&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>void pthread_testcancel()&lt;/code>&lt;/td>
&lt;td>创建线程取消点&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="12-接口用法">1.2 接口用法&lt;/h3>
&lt;h4 id="121-创建线程">1.2.1 创建线程&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">pthread_create&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">pthread_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">pthread_attr_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">attr&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">start_routine&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">arg&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>&lt;code>pthread_t *thread&lt;/code> ：传递一个 &lt;code>pthread_t&lt;/code> 类型的指针变量，也可以直接传递某个 &lt;code>pthread_t&lt;/code> 类型变量的地址。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>const pthread_attr_t *attr&lt;/code>：用于手动设置新建线程的属性，例如线程的调用策略、线程所能使用的栈内存的大小等。大部分场景中，我们都不需要手动修改线程的属性，将 &lt;code>attr&lt;/code> 参数赋值为 &lt;code>NULL&lt;/code>，&lt;code>pthread_create()&lt;/code> 函数会采用系统默认的属性值创建线程。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>void *(*start_routine) (void *)&lt;/code>：以函数指针的方式指明新建线程需要调用的函数，该函数的参数最多有 1 个（可以省略不写），形参和返回值的类型都必须为 &lt;code>void*&lt;/code> 类型。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>void *arg&lt;/code>：指定传递给 &lt;code>start_routine&lt;/code> 函数的实参，当不需要传递任何数据时，将 &lt;code>arg&lt;/code> 赋值为 &lt;code>NULL&lt;/code> 即可。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="122-分离线程">1.2.2 分离线程&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">pthread_detach&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">pthread_t&lt;/span> &lt;span class="kr">thread&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>表示线程运行结束后资源可被回收（线程所占用堆栈和线程描述符）。&lt;/li>
&lt;/ul>
&lt;h4 id="123-比较线程-id">1.2.3 比较线程 ID&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">pthread_equal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">pthread_t&lt;/span> &lt;span class="n">t1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">pthread_t&lt;/span> &lt;span class="n">t2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>比较线程 &lt;code>t1&lt;/code> 和 &lt;code>t2&lt;/code> 的线程 ID。如果相等，返回非零值；如果不相等，返回 0。&lt;/li>
&lt;/ul>
&lt;h4 id="124-终止线程">1.2.4 终止线程&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">pthread_exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">value_ptr&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>void *value_ptr&lt;/code>： 可以指向任何类型的数据，它指向的数据将作为线程退出时的返回值。如果线程不需要返回任何数据，将参数置为 &lt;code>NULL&lt;/code> 即可。&lt;/li>
&lt;/ul>
&lt;h4 id="125-挂起并等待指定线程终止">1.2.5 挂起并等待指定线程终止&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">pthread_join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">pthread_t&lt;/span> &lt;span class="kr">thread&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="n">value_ptr&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>pthread_t thread&lt;/code>：等待终止的目标线程。&lt;/li>
&lt;li>&lt;code>void **value_ptr&lt;/code>：接收到的返回值，为 &lt;code>void pthread_exit(void *value_ptr)&lt;/code> 中 &lt;code>void *value_ptr&lt;/code> 指向的内容。&lt;/li>
&lt;li>如果调用 &lt;code>int pthread_join()&lt;/code> 函数的线程被取消，目标线程不会被分离。&lt;/li>
&lt;/ul>
&lt;h4 id="126-向线程发送信号">1.2.6 向线程发送信号&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">pthread_kill&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">pthread_t&lt;/span> &lt;span class="kr">thread&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">sig&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>sig&lt;/code>：向指定线程 &lt;code>pthread_t thread&lt;/code> 发送的信号。&lt;/li>
&lt;/ul>
&lt;h4 id="127-仅一次调用指定函数">1.2.7 仅一次调用指定函数&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">pthread_once_t&lt;/span> &lt;span class="n">once_control&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">PTHREAD_ONCE_INIT&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">pthread_once&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">pthread_once_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">once_control&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">init_routine&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>pthread_once_t *once_control&lt;/code>：指定函数 &lt;code>init_routine&lt;/code> 是否被调用的标志，需赋初值 &lt;code>PTHREAD_ONCE_INIT&lt;/code> 以保证 &lt;code>int pthread_once()&lt;/code> 函数正常调用。&lt;/li>
&lt;li>&lt;code>void (*init_routine)(void)&lt;/code>：指定函数 &lt;code>init_routine&lt;/code>，在 &lt;code>once_control&lt;/code> 值为 &lt;code>PTHREAD_ONCE_INIT&lt;/code> 时，可被正常调用，随后使用再次调用 &lt;code>int pthread_once()&lt;/code> 函数与相同 &lt;code>once_control&lt;/code>，将不会再次调用 &lt;code>init_routine&lt;/code> 函数。&lt;/li>
&lt;/ul>
&lt;h4 id="128-返回线程-id">1.2.8 返回线程 ID&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">pthread_t&lt;/span> &lt;span class="nf">pthread_self&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>返回调用该函数的线程的线程 ID。&lt;/li>
&lt;/ul>
&lt;h4 id="129-向线程发送取消信号">1.2.9 向线程发送取消信号&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">pthread_cancel&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">pthread_t&lt;/span> &lt;span class="kr">thread&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>发送终止信号给 &lt;code>thread&lt;/code> 线程，如果成功则返回 0，否则为非 0 值。发送成功并不意味着 &lt;code>thread&lt;/code> 会终止。&lt;/li>
&lt;/ul>
&lt;h4 id="1210-设置本线程对取消信号的反应">1.2.10 设置本线程对取消信号的反应&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">pthread_setcancelstate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">state&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">oldstate&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>int state&lt;/code> ：具有两种取值 &lt;code>PTHREAD_CANCEL_ENABLE&lt;/code>（缺省）和 &lt;code>PTHREAD_CANCEL_DISABLE&lt;/code>，
分别表示收到信号后设为 CANCLED 状态和忽略 CANCEL 信号继续运行；&lt;code>old_state&lt;/code> 如果不为 &lt;code>NULL&lt;/code> 则存入原来的 Cancel 状态以便恢复。&lt;/li>
&lt;/ul>
&lt;h4 id="1211-设置本线程取消动作的执行时机">1.2.11 设置本线程取消动作的执行时机&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">pthread_setcanceltype&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">type&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">oldtype&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>int type&lt;/code> ：具有两种取值 &lt;code>PTHREAD_CANCEL_DEFFERED&lt;/code> 和 &lt;code>PTHREAD_CANCEL_ASYCHRONOUS&lt;/code>，仅当 Cancel 状态为 Enable 时有效，分别表示收到信号后继续运行至下一个取消点再退出和立即执行取消动作（退出）；&lt;code>oldtype&lt;/code> 如果不为 &lt;code>NULL&lt;/code> 则存入运来的取消动作类型值。&lt;/li>
&lt;/ul>
&lt;h4 id="1212-创建线程取消点">1.2.12 创建线程取消点&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">pthread_testcancel&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>在不包含取消点，但是又需要取消点的地方创建一个取消点，以便在一个没有包含取消点的执行代码线程中响应取消请求。&lt;/li>
&lt;/ul>
&lt;h2 id="2-同步原语">2 同步原语&lt;/h2>
&lt;h3 id="21-互斥锁">2.1 互斥锁&lt;/h3>
&lt;h4 id="211主要函数接口">2.1.1主要函数接口&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>函数名&lt;/th>
&lt;th>功能&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>pthread_mutex_init()&lt;/code>&lt;/td>
&lt;td>初始化一个互斥锁&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>pthread_mutex_destroy()&lt;/code>&lt;/td>
&lt;td>销毁一个互斥锁&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>pthread_mutex_lock()&lt;/code>&lt;/td>
&lt;td>加锁&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>pthread_mutex_trylock()&lt;/code>&lt;/td>
&lt;td>尝试加锁&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>pthread_mutex_unlock()&lt;/code>&lt;/td>
&lt;td>解锁&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="212接口用法">2.1.2接口用法&lt;/h4>
&lt;h5 id="2121初始化一个互斥锁互斥量">2.1.2.1初始化一个互斥锁(互斥量)&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">pthread_mutex_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">pthread_mutex_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kr">restrict&lt;/span> &lt;span class="n">mutex&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="kt">pthread_mutexattr_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kr">restrict&lt;/span> &lt;span class="n">attr&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>&lt;strong>mutex&lt;/strong>：传出参数，调用时应传 &lt;strong>&amp;amp;mutex&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>attr&lt;/strong>：互斥量属性。是一个传入参数，通常传&lt;strong>NULL&lt;/strong>，选用&lt;strong>默认属性&lt;/strong>(线程间共享)。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>互斥锁初始化有两种方式：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>静态初始化：如果互斥锁 &lt;strong>mutex&lt;/strong> 是静态分配的（定义在全局，或加了static关键字修饰），可以直接使用宏进行初始化。&lt;code>e.g. pthead_mutex_t muetx = PTHREAD_MUTEX_INITIALIZER;&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>动态初始化：局部变量应采用动态初始化。&lt;code>e.g. pthread_mutex_init(&amp;amp;mutex, NULL)&lt;/code>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h5 id="2122-加锁">2.1.2.2 &lt;strong>加锁&lt;/strong>&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">pthread_mutex_lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">pthread_mutex_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>可视作mutex&amp;ndash;&lt;/li>
&lt;/ul>
&lt;h5 id="2123-尝试加锁">2.1.2.3 &lt;strong>尝试加锁&lt;/strong>&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">pthread_mutex_trylock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">pthread_mutex_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2124解锁">2.1.2.4&lt;strong>解锁&lt;/strong>&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">pthread_mutex_unlock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">pthread_mutex_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>可视作mutex++&lt;/li>
&lt;/ul>
&lt;h4 id="2125销毁互斥锁">2.1.2.5&lt;strong>销毁互斥锁&lt;/strong>&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">pthread_mutex_destroy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">pthread_mutex_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="22-条件变量">2.2 条件变量&lt;/h3>
&lt;h4 id="221主要函数接口">2.2.1主要函数接口&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>函数名&lt;/th>
&lt;th>功能&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>pthread_cond_init()&lt;/code>&lt;/td>
&lt;td>初始化一个条件变量&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>pthread_cond_wait()&lt;/code>&lt;/td>
&lt;td>阻塞等待一个条件变量&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>pthread_cond_timedwait()&lt;/code>&lt;/td>
&lt;td>限时等待一个条件变量&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>pthread_cond_signal()&lt;/code>&lt;/td>
&lt;td>唤醒至少一个阻塞在条件变量上的线程&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>pthread_cond_broadcast()&lt;/code>&lt;/td>
&lt;td>唤醒全部阻塞在条件变量上的线程&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>pthread_cond_destroy()&lt;/code>&lt;/td>
&lt;td>销毁一个条件变量&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="222接口用法">2.2.2接口用法&lt;/h4>
&lt;h5 id="2221初始化一个条件变量">2.2.2.1&lt;strong>初始化一个条件变量&lt;/strong>&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">pthread_cond_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">pthread_cond_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kr">restrict&lt;/span> &lt;span class="n">cond&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="kt">pthread_condattr_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kr">restrict&lt;/span> &lt;span class="n">attr&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>&lt;strong>cond&lt;/strong>：传出参数，传出参数，调用时应传 &amp;amp;mutex&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>attr&lt;/strong>：attr表条件变量属性，通常为默认值，传NULL即可&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可以使用静态初始化的方法，初始化条件变量：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">pthread_cond_t&lt;/span> &lt;span class="n">cond&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">PTHREAD_COND_INITIALIZER&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="2222阻塞等待一个条件变量">2.2.2.2&lt;strong>阻塞等待一个条件变量&lt;/strong>&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">pthread_cond_wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">pthread_cond_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kr">restrict&lt;/span> &lt;span class="n">cond&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">pthread_mutex_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kr">restrict&lt;/span> &lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>函数作用：&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>阻塞等待条件变量cond（参1）满足&lt;/p>
&lt;/li>
&lt;li>
&lt;p>释放已掌握的互斥锁（解锁互斥量）相当于&lt;code>pthread_mutex_unlock(&amp;amp;mutex);&lt;/code>&lt;/p>
&lt;p>&lt;strong>1,2两步为一个原子操作。&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当被唤醒，&lt;code>pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁&lt;/code>pthread_mutex_lock(&amp;amp;mutex);&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h5 id="2223限时等待一个条件变量">2.2.2.3&lt;strong>限时等待一个条件变量&lt;/strong>&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">pthread_cond_timedwait&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">pthread_cond_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kr">restrict&lt;/span> &lt;span class="n">cond&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">pthread_mutex_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kr">restrict&lt;/span> &lt;span class="n">mutex&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">timespec&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="kr">restrict&lt;/span> &lt;span class="n">abstime&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>abstime：&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>查看struct timespec结构体。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">timespec&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">time_t&lt;/span> &lt;span class="n">tv_sec&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* seconds */&lt;/span> &lt;span class="err">秒&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">long&lt;/span> &lt;span class="n">tv_nsec&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* nanosecondes*/&lt;/span> &lt;span class="err">纳秒&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>形参abstime使用的是绝对时间。&lt;/strong>&lt;/p>
&lt;p>如：time(NULL)返回的就是绝对时间。而alarm(1)是相对时间，相对当前时间定时1秒钟。初始化&lt;code>struct timespec t = {1, 0};&lt;/code>则&lt;code>pthread_cond_timedwait (&amp;amp;cond, &amp;amp;mutex, &amp;amp;t);&lt;/code> 只能定时到 1970年1月1日 00:00:01秒 。&lt;/p>
&lt;p>&lt;strong>正确用法：&lt;/strong>&lt;/p>
&lt;p>使用&lt;code>time_t cur = time(NULL); &lt;/code>获取当前时间。&lt;/p>
&lt;p>初始化&lt;code>struct timespec t;&lt;/code> 定义timespec 结构体变量t&lt;/p>
&lt;p>令&lt;code>t.tv_sec = cur+1;&lt;/code> 定时1秒&lt;/p>
&lt;p>再进行传参&lt;code>pthread_cond_timedwait (&amp;amp;cond, &amp;amp;mutex, &amp;amp;t); &lt;/code>传参&lt;/p>
&lt;h5 id="2224唤醒至少一个阻塞在条件变量上的线程">2.2.2.4.&lt;strong>唤醒至少一个阻塞在条件变量上的线程&lt;/strong>&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">pthread_cond_signal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">pthread_cond_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">cond&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="2225唤醒全部阻塞在条件变量上的线程">2.2.2.5&lt;strong>唤醒全部阻塞在条件变量上的线程&lt;/strong>&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">pthread_cond_broadcast&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">pthread_cond_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">cond&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="2226销毁一个条件变量">2.2.2.6&lt;strong>销毁一个条件变量&lt;/strong>&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">pthread_cond_destroy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">pthread_cond_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">cond&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="23-读写锁">2.3 读写锁&lt;/h3>
&lt;h4 id="231主要函数接口">2.3.1主要函数接口&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>函数名&lt;/th>
&lt;th>功能&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code> int pthread_rwlock_init()&lt;/code>&lt;/td>
&lt;td>初始化一个读写锁&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>int pthread_rwlock_rdlock()&lt;/code>&lt;/td>
&lt;td>加读锁&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code> int pthread_rwlock_wrlock()&lt;/code>&lt;/td>
&lt;td>加写锁&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>int pthread_rwlock_tryrdlock()&lt;/code>&lt;/td>
&lt;td>尝试获得读模式的读写锁&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code> int pthread_rwlock_trywrlock()&lt;/code>&lt;/td>
&lt;td>尝试获得写模式的读写锁&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code> int pthread_rwlock_unlock()&lt;/code>&lt;/td>
&lt;td>释放读写锁&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>int pthread_rwlock_destroy()&lt;/code>&lt;/td>
&lt;td>销毁读写锁&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="232接口用法">2.3.2接口用法&lt;/h4>
&lt;h5 id="2321-初始化一个读写锁">2.3.2.1 &lt;strong>初始化一个读写锁&lt;/strong>&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">pthread_rwlock_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">pthread_rwlock_t&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">rwlock&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="kt">pthread_rwlockattr_t&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">attr&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>rwclock为读写锁指针，attr为读写锁属性指针。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>函数按读写锁属性对读写锁进行初始化。如果 attr 为 NULL，则使⽤缺省的读写锁属性，其作⽤与传递缺省读写锁属性对象的地址相同。初始化读写锁之后，该锁可以使⽤任意次数，⽽⽆需重新初始化。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h5 id="2322-加读锁">2.3.2.2 &lt;strong>加读锁&lt;/strong>&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="nf">pthread_rwlock_rdlock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">pthread_rwlock_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">rwlock&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>在读模式下锁定读写锁，成功返回０，否则返回错误编号，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>错误返回值的定义只是针对不正确使用读写锁的情况(如未经初始化的锁)，或者试图获取已拥有的锁从而可能产生死锁的情况。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h5 id="2323-加写锁">2.3.2.3 &lt;strong>加写锁&lt;/strong>&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">pthread_rwlock_wrlock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">pthread_rwlock_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">rwlock&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>在写模式下锁定读写锁,返回值如加读锁&lt;/li>
&lt;/ul>
&lt;h5 id="2324-尝试获得读模式的读写锁">2.3.2.4 &lt;strong>尝试获得读模式的读写锁&lt;/strong>&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">pthread_rwlock_tryrdlock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">pthread_rwlock_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">rwlock&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>如果可以获取返回0，不可以获取出错返回EBUSY&lt;/li>
&lt;/ul>
&lt;h5 id="2325-尝试获得写模式的读写锁">2.3.2.5 &lt;strong>尝试获得写模式的读写锁&lt;/strong>&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">pthread_rwlock_trywrlock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">pthread_rwlock_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">rwlock&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>如果可以获取返回0，不可以获取出错返回EBUSY&lt;/li>
&lt;/ul>
&lt;h5 id="2326-释放读写锁">2.3.2.6 &lt;strong>释放读写锁&lt;/strong>&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">pthread_rwlock_unlock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">pthread_rwlock_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">rwlock&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>释放读写锁，包括读锁与写锁&lt;/li>
&lt;/ul>
&lt;h5 id="2327-销毁读写锁">2.3.2.7 &lt;strong>销毁读写锁&lt;/strong>&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="nf">pthread_rwlock_destroy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">pthread_rwlock_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">rwlock&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>此函数只是反初始化读写锁变量，并没有释放内存空间，如果读写锁变量是通过malloc等函数申请的，那么需要在free掉读写锁变量之前调用pthread_rwlock_destory函数。&lt;/li>
&lt;/ul>
&lt;h2 id="3-线程api的使用准则">3 线程API的使用准则&lt;/h2>
&lt;blockquote>
&lt;p>此部分译自OSTEP 27.6 Summary&lt;/p>
&lt;/blockquote>
&lt;p>当你使用线程库来构建程序时，必须记住一些xio但很重要的事情：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>保持简单&lt;/strong>： 这是最重要的一件事，你应该尽量保持你涉及到锁定和发出信号（lock&amp;amp;signal）的代码
简单，以免出现一些神必的线程间相互作用导致的错误。&lt;/li>
&lt;li>&lt;strong>尽量减少线程之间的互动&lt;/strong>：每一种交互都应该都要仔细考虑，并采用经过验证的方法来构建。&lt;/li>
&lt;li>&lt;strong>初始化同步原语&lt;/strong>：如果不这么做，有时会出现你在调试时🈚问题，但是上环境以后出现非常诡异的错误。&lt;/li>
&lt;li>&lt;strong>检查你的返回代码&lt;/strong>：当然，在你做的任何C和UNIX编程中，你应该检查每一个返回代码。
这里也是如此。如果不这样做，就会导致奇怪的和难以理解的行为，&lt;del>导致你砸键盘&lt;/del>。&lt;/li>
&lt;li>&lt;strong>在传递参数和返回值时小心处理&lt;/strong>：特别是在传递在堆栈空间内的指针时，你可能会出错。&lt;/li>
&lt;li>&lt;strong>注意每个线程都有自己的堆栈&lt;/strong>：这和上一条相关请记住，每个线程都有自己的堆栈。因此，如果你有一个
本地分配的变量，它本质上是该线程的私有变量；其他线程不可能(轻易）访问它。要在线程之间共享数据，这些值必须在
在堆中，或者其他一些全局可访问的位置。&lt;/li>
&lt;li>&lt;strong>请使用条件变量在线程间传递信号&lt;/strong>：虽然使用信号（signal flag）很简单且诱人，但是请不要这么做。&lt;/li>
&lt;li>&lt;strong>查看手册&lt;/strong>&lt;del>RTFM&lt;/del>：特别是在Linux上，pthread 手册的信息量很大，讨论了很多这里提出的细微差别，通常甚至更详细。仔细阅读它们吧~&lt;/li>
&lt;/ul>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Pthreads" target="_blank" rel="noopener">pthreads Wiki&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.ibm.com/docs/en/aix/7.2?topic=files-pthreadh-file" target="_blank" rel="noopener">pthread.h Document by IBM&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://pubs.opengroup.org/onlinepubs/7908799/xsh/pthread.h.html" target="_blank" rel="noopener">pthread.h Document by OpenGroup&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://pages.cs.wisc.edu/~remzi/OSTEP/" target="_blank" rel="noopener">Operating System: Three Easy Pieces&lt;/a>,Remzi H. Arpaci-Dusseau and Andrea C. Arpaci-Dusseau, Arpaci-Dusseau Books, August, 2018 (Version 1.00)&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>About Semaphore</title><link>https://example.com/post/about-semaphore/</link><pubDate>Tue, 11 Oct 2022 12:06:12 +0800</pubDate><guid>https://example.com/post/about-semaphore/</guid><description>&lt;p>&lt;strong>信号量应用 3、用信号量描述同步：&lt;/strong>&lt;/p>
&lt;p>&lt;strong>例：&lt;/strong> 某控制测量系统中，数据采集任务反复把
所采集的数据送入一个单缓冲区；计算任务不断从
该单缓冲区取出数据进行计算。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">var&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">flag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">collection&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">ture&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 采集数据；
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 将采集的数据放入buffer;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">calculate&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">ture&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 从buf中取出数据;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 计算处理;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>🤔 &lt;strong>此处使用signal flag替代信号量，会不会产生问题？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Answer&lt;/strong>：可以看到此处&lt;code>while(flag==1);&lt;/code>和&lt;code>while(flag==0);&lt;/code>均为循环忙等的操作，
因此该方法和教材中整型信号量是一致的，因此会出现&lt;strong>让权等待&lt;/strong>、&lt;strong>有限等待&lt;/strong>不满足的问题。&lt;/p>
&lt;blockquote>
&lt;p>😉 问题解答结束，以下为相关的补充内容&lt;/p>
&lt;/blockquote>
&lt;h2 id="1-整型信号量">1 整型信号量&lt;/h2>
&lt;p>教材：整型信号量：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">typedef&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">semaphore&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">semaphore&lt;/span> &lt;span class="n">sem&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">sem&lt;/span>&lt;span class="o">&amp;lt;=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">;&lt;/span> &lt;span class="cm">/* 循环忙等 */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sem&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">semaphore&lt;/span> &lt;span class="n">sem&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sem&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>存在循环忙等，和PPT给出方法是一致的，该方法显然不满足：&lt;/p>
&lt;ul>
&lt;li>让权等待：P操作循环忙等。&lt;/li>
&lt;li>有限等待：某一线程V操作后其余线程竞争资源，其结果不确定。&lt;/li>
&lt;/ul>
&lt;h2 id="2-整型信号量的小改进">2 整型信号量的小改进&lt;/h2>
&lt;p>此处我们消除循环忙等的过程，通过&lt;code>yield()&lt;/code>让线程转让CPU使用权。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">typedef&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">semaphore&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">semaphore&lt;/span> &lt;span class="n">sem&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">bool&lt;/span> &lt;span class="n">succ&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">succ&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">sem&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sem&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">succ&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">succ&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">yield&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">semaphore&lt;/span> &lt;span class="n">sem&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sem&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是此时发现仅满足让权等待（&lt;code>yield()&lt;/code>对应线程让权），但不满足有限等待（同1部分）。&lt;/p>
&lt;h2 id="3-记录型信号量">3 记录型信号量&lt;/h2>
&lt;p>教材：记录型信号量：利用PCB链式队列实现，仅需保证单条操作的原子性（through model-checker）&lt;/p>
&lt;blockquote>
&lt;p>model-checker &lt;a href="https://luminolt.cn/resources/semaphore/" target="_blank" rel="noopener">信号量的状态转移图&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="n">PCB&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="n">semaphore&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">semaphore&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">sem&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">S&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">S&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">value&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">block&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">S&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">semaphore&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">sem&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">S&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">S&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">value&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">wakeup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">S&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="4-信号量api实现">4 信号量（API实现）&lt;/h2>
&lt;p>进一步：信号量实际的实现，思想和教材中的记录型信号量相同，对应&lt;code>semaphore.h&lt;/code>
的抽象。由于&lt;code>semaphore.h&lt;/code>的源码不是很好找（笔者的系统上这个被链接了，需要一些
反汇编），此处给出OSTEP的实现：&lt;/p>
&lt;blockquote>
&lt;p>Ref: &lt;a href="https://github.com/remzi-arpacidusseau/ostep-code/blob/master/threads-sema/zemaphore.h" target="_blank" rel="noopener">https://github.com/remzi-arpacidusseau/ostep-code/blob/master/threads-sema/zemaphore.h&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#ifndef __zemaphore_h__
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define __zemaphore_h__
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">__Zem_t&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">pthread_cond_t&lt;/span> &lt;span class="n">cond&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">pthread_mutex_t&lt;/span> &lt;span class="n">lock&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="n">Zem_t&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">Zem_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Zem_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">z&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">z&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">Cond_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">z&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">cond&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">Mutex_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">z&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">Zem_wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Zem_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">z&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">Mutex_lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">z&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">z&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">value&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">Cond_wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">z&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">cond&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">z&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">z&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">Mutex_unlock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">z&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">Zem_post&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Zem_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">z&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">Mutex_lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">z&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">z&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">Cond_signal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">z&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">cond&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">Mutex_unlock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">z&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#ifdef __APPLE__
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="k">typedef&lt;/span> &lt;span class="n">Zem_t&lt;/span> &lt;span class="kt">sem_t&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define Sem_wait(s) Zem_wait(s)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define Sem_post(s) Zem_post(s)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define Sem_init(s, v) Zem_init(s, v)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#endif &lt;/span>&lt;span class="c1">// __zemaphore_h__
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到使用了一个互斥锁和条件变量。&lt;/p>
&lt;p>事实上条件变量对应上面的的PCB队列，而&lt;code>block()&lt;/code>和&lt;code>wakeup()&lt;/code>的原子性，
对应这里条件变量的&lt;code>wait()&lt;/code>和&lt;code>signal()&lt;/code>通过互斥锁保证。&lt;/p></description></item></channel></rss>